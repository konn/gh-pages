<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>konn-san.com 建設予定地</title>
    <link href="https://konn-san.com/feed.xml" rel="self" />
    <link href="https://konn-san.com" />
    <id>https://konn-san.com/feed.xml</id>
    <author>
        <name>Hiromi ISHII</name>
        <email>konn.jinro_at_gmail.com</email>
    </author>
    <updated>2023-01-01T17:35:00+09:00</updated>
    <entry>
      <title>Disco Elysium - 頽廃の都マルティネーズで世界の迷宮に迷い込もう</title>
      <link href="https://konn-san.com/articles/2023-01-01-disco-elysium-invitation-to-martinaise.html" />
      <id>https://konn-san.com/articles/2023-01-01-disco-elysium-invitation-to-martinaise.html</id>
      <published>2023-01-01T17:35:00+09:00</published>
      <updated>2023-01-01T17:35:00+09:00</updated>
      <summary type="html"><![CDATA[<section id="新年の挨拶も早々にゲームの布教をする" class="level1">
<h2>新年の挨拶も早々にゲームの布教をする</h2>
<p>Disco Elysium というゲームがある。
2019年に発売されたエストニア産のゲームで、私がその存在を知ったのは確か以下のツイートがRTされてきたのがきっかけだったと思う：</p>
<blockquote class="twitter-tweet">
<p lang="ja" dir="ltr">
記憶喪失の刑事が陰鬱な町で起きた殺人事件の真相を24もの自分のスキルと脳内会議しながら推理するという<br>、ゲーム賞取りまくったオープンワールド怪物ボリュームミステリーRPG「Disco
Elysium」が翻訳希望投票を始めた！日本はまだ5位！これ遊べないのは大損！皆投票しよう！<a href="https://t.co/z4KlkgwsOF">https://t.co/z4KlkgwsOF</a>
<a href="https://t.co/UyqcyVhre0">pic.twitter.com/UyqcyVhre0</a>
</p>
— タンサンあさと (@tansanasa)
<a href="https://twitter.com/tansanasa/status/1260812736830689281?ref_src=twsrc%5Etfw">May
14, 2020</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>去る2022年8月に遂に日本語訳が出たので、悪いことは言わないので是非買ってやってほしいというのが、よりにもよって2023年の新年早々に久々にこのサイトを更新した動機になる。新年明けましておめでとうございます。
翻訳は、エイドリアン・マッキンティの〈刑事ダフィ〉シリーズなどを手掛ける武藤陽生氏が担当しており、しばしば難解と言われる本ゲームの膨大な英語を雰囲気そのままに見事に訳出されているので安心してほしい。</p>
  <div class="embed w-100 my-4 justify-content-center row py-0">
    

  </div>

<p>私はといえば、8月にSwitch版を購入して以来、ちまちまと週末に進めたりしていた。
謎めいた頽廃的な雰囲気が催眠的でたいへん心地良く、とはいえ作品世界に没入するのは体力を使うので、仕事がそこそこ忙しかったのと他の予定があったのもあり、少しだけ進めて数ヶ月放置していた。
年末年始にまとまった休みをとることにしたので、じゃあ帰省に合わせて一週間くらいかけてゆっくり遊ぶか、とプレイを再開したところ、二時間弱の電車移動が一瞬に感じるほど熱中してしまい、忘年会から帰る終電を降りても目が話せず、久し振りに「終電を降りた駅のホームで区切りのいいところまで小説を一気読みする奴」をやった。ゲームじゃん、って？本作はかなりのボリュームのテキストから成る（<a href="https://news.denfaminicogamer.jp/kikakuthetower/200630z">一説による</a>とハリー・ポッターシリーズ全七巻分）ので、もう小説といっていいでしょう。
結果、年末年始に一週間くらいかけてゆっくりやるつもりだったのが、忘年会の終電を降りたあとはもう実家の自室で明け方の5時くらいまで熱中してエンディングまで一気呵成に辿り着いてしまった。
これは本当にやばいぞということで、ミステリや SF
を好む友人知人や赤の他人に布教する目的で筆を執ったという次第。</p>
</section>
<section id="disco-elysium-とはどんなゲームなのか" class="level1">
<h2>Disco Elysium とはどんなゲームなのか？</h2>
<p>冒頭で引用したタンサンあさとさんのツイートが簡潔にこのゲームを要約して下さっている。
<strong>アル中で記憶喪失の男となって、脳内の幾つものスキルと会話しながら、頽廃的な都市で吊るされた男の死の真相を追う</strong>というものだ。</p>
<p>この時点で興味を持った方は、それ以上の情報を入れずにゲームに没入していただいたほうがいいので、以下の記事は読まずにそのまま購入＆プレイに没頭して頂くのがよいだろう。
というのも、この主人公の男は自分の人生に関する記憶だけではなく、<strong>作品世界の歴史・成り立ち記憶までも失っており</strong>、事件の謎だけではなく<strong>そもそもこの世界は何なのか？という謎も含めて追求する</strong>というのが大きな醍醐味になっており、主人公に寄り添って作品世界に没入する魅力の一端を成しているからだ。
Steam （Win/macOS 両対応）や PlayStation、Switch
で遊ぶことができる。私は Switch
版を買ったが、操作性はちょっと悪い程度で体験を損わずにちゃんとプレイはできたが、もともと
PC ゲームなので、マウスクリックができる Steam
のものを買うのが楽かもしれない。</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

  <div class="embed w-100 my-4 justify-content-center row py-0">
    

  </div>

  <div class="embed w-100 my-4 justify-content-center row py-0">
    

  </div>

<p>まだ様子見をしている御仁に向け、蛇足を承知で重篤なネタバレを極力避けながら、Disco
Elysium とはいかなる作品なのか紹介していこう。</p>
<p>本作を一言でいうなら、<strong>腐敗が蔓延る頽廃した新・新大陸植民地の港湾都市を舞台にした、レトロパンク異世界幻想SF・ハードボイルド・サイコ探偵・オープンワールドアドベンチャー電子TRPGノベルゲーム</strong>だ。随分とてんこもりだと思うだろう。しかし、このゲームの過剰さを表現するには、これでもちょっと短かすぎるくらいだ。</p>
<p>以下、それぞれの要素について説明させてもらおう。</p>
<section id="作品の舞台マルティネーズと核となる事件について" class="level2">
<h3>作品の舞台〈マルティネーズ〉と核となる事件について</h3>
<p>上でちらっと述べたように、この作品では<strong>事件の秘密と世界の秘密が密接に絡み合っており</strong>、我々の知る世界とは異なる歴史を歩んでいる。
作品の舞台は、〈新・新世界〉としてしられるインスリンデ群島を構成する国家の一つレヴァショール、そのかつての中心地であった<strong>港湾都市・マルティネーズ</strong>を、記憶喪失の男が事件と自身と世界の秘密を求めて彷徨い歩くというのが本作のコンセプトだ。
この世界はいかなる世界なのか？というのを解き明かすのもこのゲームの重要な要素の一つなので、そこまで深い説明はしないが、徐々に浮かび上がる世界像それ自体も魅力の一つなので、ここではその一端を説明しておこう。</p>
<p>ゲームの冒頭、男は荒れ果てたホテルの一室で奇妙な夢目覚める。ソファベッドはめちゃくちゃで、あたりに酒瓶と服とが散乱している。
<ruby><rb>宿酔</rb><rp>（</rp><rt>ふつかよ</rt><rp>）</rp></ruby>いの頭を抱えてシャワー室に向かうと、鏡に映ったのは奇妙な笑顔を貼り付かせた見知らぬ男の顔だった。</p>
<p>部屋を出てホテルをさまよううち、他の宿泊客やバーテンダー……もとい、カフェテリア経営者らと出会って、自分の蛮行を知る。どうもかなり荒んでいたらしい。
ホテルのロビーには、自分とバディを組んで事件を捜査すべく別の署から派遣されてきたキム・キツラギ警部補がいて、どうも自分はレヴァショールの<strong>警察機能を担う「レヴァショール市民軍（Revachol
Citizens Militia; RCM）」のいち捜査官であるらしい</strong>ことがわかる。
主人公はアルコールに冒されて完全に記憶がパアになってしまっているので、こんな説明を訊いても一向にピンと来ない。</p>
<p>事件は主人公が宿泊するホテルバー〈ワーリング・イン・ラグズ〉の裏庭で起きた。
マルティネーズを訪れていた傭兵の死体が木に吊るされた状態で発見されたのだ。
しかも、死体は住民の誰もが見ていたにも関わらず、匿名の市民がRCMに通報するまで発生から一週間放置されていたというのだ。</p>
<p>何故それまでずっと放置されていたのか？それには、このマルティネーズ、ひいてはレヴァショールが辿った歴史の特殊性が関連している。
マルティネーズは港湾都市で、時あたかも労働組合と巨大企業の抜き差しならない睨み合いが続いている。労働組合の権力は絶大で、街を支配していると言ってよく、組合傘下のごろつき自警団〈ハーディ・ボーイズ〉が実質的な地域の警察として君臨している。
被害者の傭兵はスト破りのために企業側に雇われていた男で、事件の直前〈ハーディ・ボーイズ〉と揉め毎を起こしていた。だからこの事件には〈ハーディ・ボーイズ〉が関っている、というのは住民たちの間では公然の事実だった。彼らに睨まれれば、この街では暮らしていけない。そんな状況でRCMに通報するような住民がいるはずもなかった。では、誰が通報したのだろう？──これも重要な謎だ。</p>
<p>そもそも、RCM は市民から必ずしも良い印象を持たれていない。
それはこのレヴァショールの成り立ちに関りがある。
レヴァショールでは半世紀ほど前に共産主義革命が発生し、一時期権力を握った。
しかし、大国の同盟組織〈連合〉が内戦に介入した結果革命は頓挫して、現在レヴァショールは〈国際倫理機関〉の統治下で事実上外国勢力の植民地の扱いを受けているのだ。
RCMはこの大国たちから唯一法執行の権限を与えられた組織であり、だから市民たちからみればRCMは外国勢力の手先でしかないのだ。</p>
<p>このような逆風の中で、主人公は時折蘇える過去の記憶と自らを責め苛む夢に魘されながら、宿賃をチマチマと稼ぎつつ、市民のお願いをきいたり街の権力者たちにとりいったり、不良少年といっしょにダンスホールを作ったり、共産主義者になってみたりしながら、事件、自身、世界の秘密を迫っていく──それが
Disco Elysium だ。</p>
</section>
<section id="レトロパンク異世界幻想sf" class="level2">
<h3>レトロパンク異世界幻想SF</h3>
<p><strong>レトロパンク</strong>というのは私が今適当に考えた言葉で、本当にあるのかは知らない。無線通信やテープのようなレトロな技術の上に計算機文明が築かれているという意味でスチームパンクのような世界観だが、蒸気機関がそこまで重要な役割を果している訳でもないので、とりあえずレトロパンクと呼んでみた。
この世界では、無線電波を介して様々な処理を行う〈ラジオコンピュータ〉が普及している。
記憶素子〈フィラメント・メモリー〉を差し込んで無線越しにオペレータに復号してもらうことで、様々な記録を読んだり、情報を印刷したりすることができる。
捜査が進むに従って、こうしたガジェットを介して世界の「異常」が浮上したりもするし、また、作中では「テープを使った革新的なコンピュータ」が、頓挫した幻のイノベーションとして言及されたりもする。</p>
<p>また、この島には未確認動物を研究する夫妻が訪れており、この島に住む未確認の固有種・インスリンデナナフシの捕獲を試みている。この不思議な巨大生物は普段は葦に擬態しており人間の知覚機能を阻害するので、少数の目撃報告の他はこれまで人類に確認・捕獲されることなく見過ごされてきた──夫妻はそう主張する。
主人公はこの夫妻に話を訊き、暇つぶしにあるいはその存在を自らも信じて、その捕獲を手伝うこともできる。
もちろん、相棒のキツラギ警部補を含め多くの人はこんな荒唐無稽・幻想的な種の存在を信じてはいない。それでも、こんなものが存在してもおかしくないと思える程度には、この世界は神秘のヴェールを纏っている。
この世界ではで〈イノセンス〉と呼ばれる数名の歴史上の神秘的な指導者がおり、それぞれが人類史に大きな影響を与えているらしい──といった事実が次第に明らかになっていくが、こういった我々の世界から見て異質な異世界設定も、もしかしたらこんな幻想種がいてもおかしくないのかも……という感覚を補強する。</p>
<p>我々が主人公に寄り添って駆け巡るレヴァショールという土地は、そうした我々世界とは違う歴史・地理・技術を持った異世界なのだ。</p>
</section>
<section id="ハードボイルドサイコ探偵" class="level2">
<h3>ハードボイルド・サイコ探偵</h3>
<p>ミステリとして分類するなら、本作は<strong>ハードボイルド・サイコ探偵小説</strong>だろう。主人公は記憶喪失であるのみならず、何か起きるたびに24もの人格化された個性的なスキルたち──論理、百科事典、修辞学、演劇、概念化、視覚計算、意志力、内陸帝国、共感、権威、団結心、暗示、耐久力、痛覚閾値、肉体装置、電気化学、悪寒、薄明、手と眼の協調、知覚、反応速度、才覚、手さばき、平静──が何かを見たり聞いたりする度に脳内でのべつ幕なしに好き勝手に会話を繰り広げ、それらに影響されながら主にディスコ文化に偏った奇行を繰り広げるサイコ野郎だ。「俺は黙示録刑事だ！」といいだしたり、相手の秘密がわからなくなり急に脈絡なく服を脱ごうとしたりする。
これらのスキルは捜査をする上で必須の能力・知識を提供してくれる一方で、隙あらば主人公を共産主義陣営にオルグしようとしたり、逆にレイシストのファシストに育て上げようとしたりしてくる。</p>
<figure class="figure mx-auto">
<img class="img-fluid figure-img rounded" alt="急に脳内から話し掛けてくる〈修辞学〉。この後主人公は〈修辞学〉に「共産主義」の再構築をするようオルグされる" src="./2023-01-01-disco-elysium-imgs/call-of-rhetric.jpg">
<figcaption class="figure-caption">
急に脳内から話し掛けてくる〈修辞学〉。この後主人公は〈修辞学〉に「共産主義」の再構築をするようオルグされる
</figcaption>
</figure>
<p>この銘々かってに喚き散らしたり勝手に脳内で会話劇を繰り広げたりするスキルたちがまた素晴しい。幾つかお気に入りの例を挙げよう。</p>
<p>「百科事典」は何かを眼にする度にそれにまつわる蘊蓄を教えてくれて世界観を広げてくれるが、一方で今知りたい肝心の知識を知らずにトボケて全然違うことを話してきたりすることもあり、愛嬌がある。</p>
<figure class="figure mx-auto">
<img class="img-fluid figure-img rounded" alt="現場検屍について知りたいのに、無関係な世界最高峰の話をしてくる〈百科事典〉" src="./2023-01-01-disco-elysium-imgs/ignorance-of-encyclopedia.jpg">
<figcaption class="figure-caption">
現場検屍について知りたいのに、無関係な世界最高峰の話をしてくる〈百科事典〉
</figcaption>
</figure>
<p>「内陸帝国」は直感やオカルト的思考を司るスキルで、これが発達すると無生物や死体と会話した（つもりになった）りして手掛かりを得ることができるようになる。陰謀論的な思考に近い。</p>
<figure class="figure mx-auto">
<img class="img-fluid figure-img rounded" alt="勝手に「世界の終末」を早合点する〈内陸帝国〉" src="./2023-01-01-disco-elysium-imgs/inland-empire.jpg">
<figcaption class="figure-caption">
勝手に「世界の終末」を早合点する〈内陸帝国〉
</figcaption>
</figure>
<p>「演劇」は相手の嘘を見抜いたりする能力にあたる。こいつも時々的外れなことを言い、他のスキルたちから袋叩きにあったりするかわいげがある。</p>
<figure class="figure mx-auto">
<img class="img-fluid figure-img rounded" alt="手掛かりに対して銘々勝手な印象を話す脳内スキルたち。" src="./2023-01-01-disco-elysium-imgs/skills-converse.jpg">
<figcaption class="figure-caption">
手掛かりに対して銘々勝手な印象を話す脳内スキルたち。
</figcaption>
</figure>
<figure class="figure mx-auto">
<img class="img-fluid figure-img rounded" alt="手掛かりに対して銘々勝手な印象を話す脳内スキルたち。" src="./2023-01-01-disco-elysium-imgs/unity.jpg">
<figcaption class="figure-caption">
〈団結心〉は広い意味で仲間の心理などを推し量ったり、相手に共感してもらったりするのに使われる。キツラギ警部補は最高のバディ。
</figcaption>
</figure>
<p>また、こうした捜査に必要なスキルに加えて、夢や気絶中でのみ主人公に語り掛けてくる人格的存在もある。たとえば、ゲームの始まりはこんな感じだ。</p>
<p>ゲームを開始すると、プレイヤーが直面するのは、全き闇と物悲しい音楽。その闇のなかから、〈古代爬虫類脳〉の嗄れた声がこちらに語り掛ける。</p>
<blockquote class="blockquote">
<p>そこには何もない。生暖かい原初の闇があるだけだ。おまえの意識はその中で発酵していく。それは麦の穂先のひと粒にも満たぬほど小さい。おまえはもう何もしなくていい。</p>
<p>この先ずっと。</p>
<p>永遠に。</p>
</blockquote>
<p>「（非存在のままでいる）」などと返答しながら、この抽象的な問答を進めていく。
選んだ返答によって、長い虚無の中に沈み込んでいきもするが、やがて主人公の非存在は許容できなくなり、次第に現実に対する感覚器官が意識されてくる。
おそらくは「別れた妻」のために、主人公が捨て去りたいと願っている、現実に対する感覚が。
肉体的な「感覚」の話を拒否しようとすれば、今度は〈辺縁系〉があらわれて甲高い声で現実をつきつけてくる。</p>
<blockquote class="blockquote">
<p>おまえの口から酒の悪臭が立ちのぼる。そして……〝信じられない〟ほどの頭痛が。</p>
<p>赤々とした稲妻がおまえの頭蓋骨を貫き、その両眼を開けさせようとする。音だ。甲高い、地獄からの叫び声だ。</p>
</blockquote>
<p>こうして主人公は荒れ果てたホテルの一室で眼を覚ますのである。彼らとは今後、夜毎の睡眠時間やある事実の発見により気を失った際にこうした精神的で幻惑的な対話をしていくことになる。そのフェーズがこの作品に独特のリズムを与えている。
この作品をプレイしはじめて最初に、この別人格との催眠的とも言える対話の叙述に私は一気に魅了された。
この後も日を追うごとにこうした夢や無意識界でのやりとりは増えていくと共に、具体性を増していく。終盤、ある場所に辿り着いた際に見るつかのまの夢は、本作の中でもかなり好きな場面の一つだ。</p>
<p>とはいえ、これを英語で読むのはなかなか厳しそうだと思う（「古代爬虫類脳」なんて英語、脳科学者以外だれが知ってるんだ？）。日本語圏で本作の評判を検索してみると「難解」という形容詞がしばしば眼に入るのは、もちろん記憶喪失から世界を把握しなおすという本作の仕掛けからくるものもあるのだろうが、日本語訳以前はこうした概念的で抽象的な対話を英語で受容する必要があったのも要因の一つだろう。優れた日本語訳でプレイできる現状に感謝したい。</p>
<p>こうしてみるとわかるように、彼はある種の「信頼できない語り手」ですらある。たとえば、作中である大金持ちに会うと、相手が自分に比べてあまりに資産を持っているためにその質量で部屋の光が歪んで見える時がある。相棒のキムに訊いても別にそうは見えておらず、だからこれは主人公の研ぎ澄まされた感覚が相手がものすごい資産家であることを察知して、おもわず視界が歪んでいると信じこんでいるということになるだろう。このような主人公の思い込みと感覚の鋭さに起因するサイコっぷりを通して世界を見るという体験は、本作の大きな魅力の屋台骨になっている。とはいえ、信頼できないとはいっても基本的にその感覚器官が事件の真相に係る事実を本質的に歪めるようなことはないので、新本格のサイコミステリみたいな枠外からのどんでん返しに怯える必要はない。</p>
<p>そんなサイコ野郎な探偵が「ハードボイルド」的世界を彷徨うという落差が、本作のプレイ体験をより深みのあるものにしている。
先述のように、舞台となるマルティネーズは、公的な統治機構の支配権が完全には及ばず、巨大資本と労働組合がしのぎを削る頽廃都市で、そもそもその都市の属する国＝レヴァショールにしてからが、列強から植民地のごとき扱いを受ける主権を制限された世紀末都市だ。
謎解きの面でいっても、主人公はあちこちを見てまわり人々に話を訊いて、足で証拠を積み上げていく、という点でハードボイルド的である。
もちろん、謎解きに意外性がまったくないということではなくて、むしろこの作品は曲がり角を曲るたびに目まぐるしく様相を変えていき、プレイヤーを飽きさせない。
初期状態の主人公は心身両面でクソザコなので、能力値の振り方によっては罵倒されただけで世を儚んで死んだり、宿代をチョロマカそうとして車椅子に激突して死んだりするするので、最初からハードボイルド的なタフで感情を表に出さない探偵という訳ではない。とはいえ、スキルポイントの振り方によって主人公の性格は変わっていくし、一癖も二癖もある地元のゴロツキと丁々発止渡り合っていくことにもなる。少なくとも、舞台となる街がタフでなければ生きてゆけない世界であることは確かだ。優しく在るかどうかは、プレイヤーの選択に任されているが。</p>
</section>
<section id="オープンワールドアドベンチャー電子trpgノベルゲーム" class="level2">
<h3>オープンワールドアドベンチャー電子TRPGノベルゲーム</h3>
<p>最後にゲームシステムの話をしよう。
まあ、「オープンワールドRPG」でいいじゃん、という気もするのだが、敢えてこれくらい過剰な表現をしてもいいだろう<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>というくらいにはこのゲームは要素が詰め込まれていて、しかもそれが奇跡的な調和を保っている。</p>
<p>「電子TRPG」って、アナログなTRPG（テーブルトーク・ロールプレイングゲーム）じたいが「RPG」のレトロニムなんだから単に「RPG」でいいのでは、って？まあ、落ち着いてほしい。
まず、先に述べたように、本作では主人公の能力を人格化した24のスキルがある。
主人公は、たとえば相手の隠し事を見抜いたり、宿代をちょろまかしたりするのに、これらの能力を使う。
その際には、難易度と能力値に応じてシステム上で6面ダイス2個が振られる「スキルチェック」が行われ、出目によって成否が判定される。この判定の前後にはスキル人格との会話の形で結果報告される。TRPG的なスキルシステムをそのまま取り込むのではなく、人格を持った脳内キャラクターとして描写しているのは、作品に奥行きを与えるかなりユニークな工夫だと思う。
また、ゲームの新規開始時にも、主人公のタイプを「思想家」「神経質」「肉体派」から選ぶか、自由に能力値を振ってキャラメイクをすることができるシステムになっている。
NetHack
とかのローグライクとかもそうじゃんと言われればまあそれまでなのだが、それらと共通するTRPGのキャラメイクの楽しさへの意識がある、ということはできるだろう。
ストーリーの面でも、作中にはTRPG用カスタムダイスの職人がでてきたり、革新的なTRPGの開発に携わる人々が出て来たりするので、いわゆる電子ゲームとしての
RPG 以上にアナログな TRPG
に対する思いがこの作品に通底しているのは、ほぼまちがいないといっていい。なのでここでは、敢えて「電子TRPG」と表現したのだ<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<p>捜査順や請け負うタスクを主人公が選べるオープンワールドであることも、プレイヤーの自由な発想に従って展開していくTRPGの電子的な再現の一環であると言えるだろう（まあ、それも流行のオープンワールドRPG全般に言えることなんだろうけど）。
要所要所で物語を展開させる決定的なフラグはあるものの、基本的に誰のどんなタスクを請け負って、何をどう捜査するか、いつ誰と話すのか、という取捨選択・順序はほぼ完全にプレイヤーに委ねられている。
「トンデモ幻想生物なんかいる訳ない！警察がそんなことにかかずらってる義理はない！」と未確認生物学者の依頼を蹴る勤勉さを発揮してもいいし、相棒が寝ている間に死体から高価なアーマーを盗み取ってみせる腐敗っぷりを見せてもいい。
大企業の手先となって組合に不利な証拠を嗅ぎ回ってもいいし、失くした拳銃の情報のために組合のボスの犬になって組合に楯突く連中を脅迫したっていい。この自由さが、プレイヤーが主人公に憑依してマルティネーズという頽廃都市を徘徊している実感に大きく繋がっている。</p>
<p>で、ノベルゲームというのは、先述のようにこのゲームに含まれる膨大なテキスト（ハリポタ全7巻分！？）のためだ。このゲームはとににかく膨大な情報と描写の洪水だ。といって、コマが全部文字で埋まっているようなゲームなのかといえばそうではなく、細かく描き込まれた絵やシーンを彩る音楽が、それらに説得力を与え互いに補完しあっている。ヴィジュアルノベルというのはあまりに小説だし、小説というにはあまりにゲームである。そんな異形さが本作にはある。</p>
</section>
</section>
<section id="音楽アートワークがいい" class="level1">
<h2>音楽・アートワークがいい</h2>
<p>作品を構成するアートワークや音楽がめちゃくちゃいい。英語音声でフルボイスなのも、作品への没入感を高める。
アートワークは調べると引っ掛かるので参考にしてほしい。音楽は Amazon
Music などでも配信されているので、試聴してみるといいだろう：</p>


</section>
<section id="おわりにマルティネーズへの誘い" class="level1">
<h2>おわりに：マルティネーズへの誘い</h2>
<p>まあなんか長々と書きすぎた気がするが、このゲームの異様なまでのボリュームと質量を表すにはこれくらいではまだ足りないくらいだと思う<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。</p>
<p>ミステリとして見たときにはある意味で「熱海の捜査官」（や、録画に失敗したの最後まで観れていないがその更に元ネタの「ツイン・ピークス」）のような合理と非合理の間を漂う不思議な探偵物語でもあり、ハードボイルド的な背景もある。SFとしてみればファンタジックな架空世界を舞台にしたレトロフューチャー的な擬似スチームパンクでもある。
それほどまでに多くの要素・ディテールが詰め込まれていながら、瓦解せずに奇怪な建築のように不思議な調和が保たれている。
自我の揺らいだ主人公と一体になって、この幻想の霧に包まれた不気味な都市を駆け抜け、生きる。Disco
Elysium はそんな刺激的な作品だ。今（2023年1月1日現在） Steam
とかでもセール中みたいなんで、この年始はぜひアル中記憶喪失世紀末刑事として、マルティネーズを彷徨ってみてはいかがだろうか。</p>
</section>
<section id="おまけプレイしていてつまずいた所気をつけた方がよいこと" class="level1">
<h2>おまけ：プレイしていてつまずいた所・気をつけた方がよいこと</h2>
<p>最後に、これからプレイする／まさにプレイしているところ（私もまだ未回収の伏線があるのでこれからリプレイよてい）の人に向けて、Switch
版をプレイしていて途中まで知らずに損をした部分などを纏めておく。こういうのも含めて自力で見出したい人はここで終わってもらってかまわないです。
何かの参考になれば幸い。</p>
<section id="pc-macos-向けのほうが良いかもswitchでも十分遊べはする" class="level2">
<h3>PC / macOS 向けのほうが良いかも（Switchでも十分遊べはする）</h3>
<p>本作では、場所を移動しながら、眼に入った物や主人公の脳裡に浮かんだ思考をクリックしながら捜査を進めていく、ポイント・アンド・クリック形式のアドベンチャーゲームになっている。
Switch
版では捜査対象を左スティックで切り替えるか、本体画面を指でタップして選択するのだが、スティックによる操作性が若干悪い。グラフィックは高精細で文字が沢山あるのでテレビに接続したほうがプレイしやすい一方、そうするとスティック捜査にはちょっと手間取るかもしれない。とはいえ十分許容範囲であり、去年発表されたミステリゲームでもこれよりもっと酷い操作性のものもあるので、そこまで相対的に問題はないとも言える（私もSwitch版でクリアできたし）。
プレイ環境等を勘案して、PCでよければ Steam
版を買うなどすると快適だろう。</p>
</section>
<section id="序盤はとにかく耐久力と意志力を強化せよ回復アイテムを買え" class="level2">
<h3>序盤はとにかく「耐久力」と「意志力」を強化せよ。回復アイテムを買え</h3>
<p>選ぶスキルタイプにも依るが、序盤の主人公はかなりのポンコツである。
口喧嘩に負けて世を儚むし、転んで車椅子の女性に突っ込んだだけで御陀仏になる。
もっと詳しく言えば、主人公の主要なパラメータには「体力」と「気力」の二種類があり、どちらかがゼロになった瞬間にゲームオーバーとなる。
これらはそれぞれ「耐久力」と「意志力」の能力値をプラスすることで強化できる。これらはそれぞれ「肉体」と「精神」のカテゴリに属するスキルなので、これらのカテゴリの基準値を薬品や思考などで底上げすることでも効果は出る。</p>
<p>キャラメイクによって序盤はこれらのパラメータはクソショボなので、強化するまではホテルの東側（右）にある売店で売っている回復アイテム（マグネシウムなど）を多めに買っておくとよい。</p>
</section>
<section id="セーブはこまめに" class="level2">
<h3>セーブはこまめに</h3>
<p>序盤は体力・気力が少なかったり、修辞学が低くて相手を怒らせて撃たれてしまったりで、うっかりすると死んでしまう。
上述のようにアイテムや能力値の強化で回避できるが、はじめはなかなか間に合わないので、こまめにセーブしておこう。私は冒頭からセーブせずに一時間半くらいプレイした後で宿代をちょろまかそうとして勢い余って車椅子の女性に衝突、そのまま帰らぬひととなり全部ゼロからになったことがある。</p>
</section>
<section id="思考のスロットはスキルポイントを消費して増やせる" class="level2">
<h3>思考のスロットはスキルポイントを消費して増やせる</h3>
<p>先に上げた24のスキル以外にも、本編が展開していくに従ってさまざまな効果を持つ「思考」を内面化していくことで使える能力の底上げができたりする。
いわばスキルツリーみたいなものである。
デフォルトではこのスロットは3つしかないのだが、タスクをこなすと得られるスキルポイントはスキルの値を追加する以外にも、思考スロットをアンロックするのに使える。
この情報は知っていたのだが操作方法がわからずに後半になるまで開放方法がわからなかったので、Switch
での解放方法を紹介しておく。
といっても簡単で、解放されていないスロット（空の菱形のやつ）を指でタップするか、コントローラのスティックをひたすら左に倒して選択し
A ボタンを押せばよい。</p>
</section>
<section id="チップスはロード画面以外でも確認可能" class="level2">
<h3>チップスはロード画面以外でも確認可能</h3>
<p>ロード画面に出て来るチップス（「待って、などで始まる選択肢を選ぶと状況を説明してもらえる」などの一口アドバイス）は、メニュー画面を開くと右側のペインで確認できる。アイテムの簡単な使い方とかもそこで読める。</p>
</section>
<section id="酒薬品タバコなどの消費アイテムは一定待たないと次の消費ができない" class="level2">
<h3>酒・薬品・タバコなどの消費アイテムは一定待たないと次の消費ができない</h3>
<p>っぽい。</p>
</section>
</section>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr></hr>
<ol>
<li id="fn1" role="doc-endnote"><p>TRPG の G は Game
なんだから「ノベルゲーム」の「ゲーム」は冗語なんだけど、まあ細かいことは言うなや。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>シングルプレイなのでTRPGというよりはゲームブック的という人もどこかで見掛けた。それもまたそうだと思う。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>この記事の内容の散漫さについては……まあご寛恕を。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
    </entry>
    <entry>
      <title>古典的実現可能性モデルノート</title>
      <link href="https://konn-san.com/math/realisability.html" />
      <id>https://konn-san.com/math/realisability.html</id>
      <published>2022-09-16T21:00:00+09:00</published>
      <updated>2022-09-16T21:00:00+09:00</updated>
      <summary type="html"><![CDATA[<section id="概要" class="level1">
<h2>概要</h2>
<p>古典的実現可能性モデル（classical
realisability）の手法は，Curry–Howard対応を拡張する形で<span class="math inline">\(\mathrm{ZF}\)</span>のモデルを与える方法であり，Krivineによって導入された．
強制法を特別な場合として含むが，<span class="math inline">\(\mathrm{ZFC}\)</span>から開始しても<span class="math inline">\(\mathrm{ZF}+\neg
\mathrm{AC}\)</span>のモデルが得られるという点で強制法を真に一般化するものになっている．</p>
<p>Krivineの着想は，旧来の直観主義・構成的数学の実現可能性モデルに，Peirce’s
Law と対応することが広く知られている <code>call/cc</code>
プリミティヴを加えれば古典論理上の集合論のモデルが得られる筈である，というものである．
この達成のため，Krivine はBCKW論理に call/cc
を加えた体系を，Krivine機械と呼ばれるある種のスタックマシンを用いて解釈するという方法を採っている．</p>
<p>本稿は，元々は2017年に早稲田大学で行われた集合論セミナーでの筆者（石井）の発表の資料である．
強制法との関係をなるべく明らかにすることを目的に書き始められ，Krivineが原論文で採用したものよりも現代的な強制法の定式化に近い形で再定式化を与えたが，現時点では完全に目的を達するに至ってはいない．誰かがその道に至る道標になれば幸いである．</p>
</section>
<section id="本文リンク" class="level1">
<h2>本文リンク</h2>
<ul>
<li><a href="./realisability.pdf">PDFはこちら</a></li>
<li><a href="https://github.com/konn/realisability-note">LaTeX
Source</a></li>
</ul>
<p>元となったレジュメは6部に及ぶかなり膨大な TeX であり、TikZ
をふんだんに用いているため現時点ではHTML化が出来ていない。
従って、当面は PDF のみの提供とさせて頂く。</p>
</section>]]></summary>
    </entry>
    <entry>
      <title>Boole値モデルと強制法</title>
      <link href="https://konn-san.com/math/boolean-valued-model-and-forcing.html" />
      <id>https://konn-san.com/math/boolean-valued-model-and-forcing.html</id>
      <published>2022-06-11T18:00:00+09:00</published>
      <updated>2022-06-11T18:00:00+09:00</updated>
      <summary type="html"><![CDATA[<p>[<a href="/math/boolean-valued-model-and-forcing.pdf" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;download&#39;, &#39;ac&#39;, &#39;/math/boolean-valued-model-and-forcing.pdf&#39;)">PDF版</a>
]</p>
<section id="強制法の基本的な考え方とboole値モデル" class="level1">
<h2>強制法の基本的な考え方とBoole値モデル</h2>
<p>直観的には，現在の集合の宇宙<span class="math inline">\(V\)</span>に新しい元<span class="math inline">\(G\)</span>を付加した，新たな宇宙<span class="math inline">\(V[G]\)</span>を得たい，というのが強制法のモチヴェーションです．
しかし，そうはいっても集合の全体は既に<span class="math inline">\(V\)</span>で確定しているので，「新しい元」というのはそのままでは意味を成しません．</p>
<p>そこで，強制法では<span class="sans-serif"><strong>集合概念を拡張する</strong></span>ことを考えます．
どういう事でしょうか？ まず，一般の集合<span class="math inline">\(x \in
V\)</span>は，特性関数と同一視することで，部分関数<span class="math inline">\(x: V \dashrightarrow
2\)</span>と見做すことが出来ます． <span class="math inline">\(2\)</span>というのは「各元が<span class="math inline">\(x\)</span>に属すか？」という真偽値ですから，<span class="sans-serif"><strong>この真偽値を一般のBoole代数<span class="math inline">\(\mathbb{B}\)</span>に一般化しよう</strong></span>というというのが強制法の基本的なアイデアです．</p>
<p>このように，所属関係の真偽値を完備Boole代数<span class="math inline">\(\mathbb{B}\)</span>に一般化した集合のことを，<span class="sans-serif"><strong><span class="math inline">\(\mathbb{B}\)</span>-name</strong></span>と呼びます．</p>
<div class="definition">
<ul>
<li><p><span class="math inline">\(\left(\mathbb{B}, \leq, +, \cdot, -,
\sum, \prod, \mathbb{0}, \mathbb{1}\right)\)</span>が<span class="sans-serif"><strong>完備Boole代数</strong></span>（<em>cBa</em>）<span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span></p>
<ol>
<li><p><span class="math inline">\(\leq\)</span>は<span class="math inline">\(\mathbb{B}\)</span>上の半順序であり，<span class="math inline">\(\mathbb{0}\)</span>, <span class="math inline">\(\mathbb{1}\)</span>はそれぞれ<span class="math inline">\(\leq\)</span>に関する最小・最大元．</p></li>
<li><p><span class="math inline">\(\sum, \prod:
\mathop{\mathcal{P}}(\mathbb{B}) \to \mathbb{B}\)</span>はそれぞれ<span class="math inline">\(\mathbb{B}\)</span>の部分集合の上限・下限を与える．
特に<span class="math inline">\(x + y \mathrel{:=} \sum \left\{ x, y
\right\}\)</span>, <span class="math inline">\(x \cdot y \mathrel{:=}
\prod \left\{ x, y \right\}\)</span>と書く．</p></li>
<li><p>各<span class="math inline">\(x \in
\mathbb{B}\)</span>に対し，<span class="math inline">\(-x\)</span>は<span class="math inline">\(x\)</span>の<span class="sans-serif"><strong>補元</strong></span>と呼ばれ，<span class="math inline">\(x \cdot (-x) = 0\)</span>および<span class="math inline">\(x + (-x) = \mathbb{1}\)</span>を満たす．</p></li>
</ol></li>
<li><p>cBa <span class="math inline">\(\mathbb{B}\)</span>に対して，<span class="sans-serif"><strong><span class="math inline">\(\mathbb{B}\)</span>-nameの全体</strong></span><span class="math inline">\(V^{\mathbb{B}}\)</span>を次で定める： <span class="math display">\[\begin{gathered}
         V^{\mathbb{B}}_0 \mathrel{:=} \emptyset, \qquad
         V^{\mathbb{B}}_{\alpha + 1} \mathrel{:=}
\mathop{\mathcal{P}}(V^{\mathbb{B}}_\alpha \times \mathbb{B}),\qquad
         V^{\mathbb{B}}_\gamma \mathrel{:=} \bigcup_{\beta &lt; \gamma}
V^{\mathbb{B}}_\beta \;(\gamma: \text{limit})\\
        V^{\mathbb{B}} \mathrel{:=} \bigcup_{\alpha \in
\mathord{\mathrm{On}}} V^{\mathbb{B}}_\alpha.
        \end{gathered}\]</span> <span class="math inline">\(V^{\mathbb{B}}\)</span>の元をギリシア文字<span class="math inline">\(\sigma, \tau, \vartheta,
\dots\)</span>やドット付き文字<span class="math inline">\(\dot{x},
\dot{y}, \dots\)</span>などで表す．</p></li>
</ul>
</div>
<p>上では「部分関数」といいましたが，あとでcBa以外に一般化する際には，こっちの方が楽なので，ちょっと違う定義にしてあります．
<span class="math inline">\(\sigma \in
V^{\mathbb{B}}\)</span>に対応する部分関数を仮に<span class="math inline">\(\bar{\sigma}\)</span>と書くことにすれば， <span class="math display">\[\bar{\sigma}(\bar{\tau}) \mathrel{:=} \sum
\left\{\: b \in \mathbb{B}  \;\middle|\;  \left\langle \tau, b
\right\rangle \in \sigma \:\right\}\]</span>
によって「部分関数」を復元出来ます．</p>
<p>さて，当初の「宇宙を広げたい」という欲求からすれば，こうして創った<span class="math inline">\(V^{\mathbb{B}}\)</span>の中に<span class="math inline">\(V\)</span>が自然に埋め込まれてほしいです．
それを可能にするのが，次の<span class="math inline">\(\check{\;}\)</span>-作用素です．</p>
<div class="definition">
<p><span class="math inline">\(x \in V\)</span>に対し，<span class="math inline">\(\check{x} \in
V^{\mathbb{B}}\)</span>を整礎帰納法により次で定める： <span class="math display">\[\check{x} \mathrel{:=} \left\{\: \left\langle
\check{y}, \mathbb{1} \right\rangle  \;\middle|\;  y \in x
\:\right\}.\]</span></p>
</div>
<p>さて，このようにして一般化された集合の宇宙<span class="math inline">\(V^{\mathbb{B}}\)</span>が定義出来ました．
この<span class="math inline">\(V^{\mathbb{B}}\)</span>を集合論のモデルとして解釈したい訳ですが，所属関係の真偽値を<span class="math inline">\(\mathbb{B}\)</span>-値にしたので，モデルの解釈も<span class="math inline">\(\mathbb{B}\)</span>-値で与える必要があります．</p>
<div class="definition">
<ul>
<li><p>強制法の言語<span class="math inline">\(\mathord{\mathcal{F\!L}}\)</span>とは，二項述語記号<span class="math inline">\(\mathord{\in}\)</span>および単項述語記号<span class="math inline">\(\check{V}\)</span>を持つ言語である． また，<span class="math inline">\(x \in \check{V}\)</span>は<span class="math inline">\(\check{V}(x)\)</span>の略記法とする．</p></li>
<li><p>原子論理式<span class="math inline">\(\varphi[\vec{x}] \in
\mathord{\mathcal{F\!L}}\)</span>および<span class="math inline">\(\vec{\sigma} \in V^{\mathbb{B}}\)</span>の<span class="sans-serif"><strong>真偽値</strong></span><span class="math inline">\(\left\| \varphi[\vec{\sigma}]
\right\|_{\,\mathbb{B}}\)</span>を次のような<span class="math inline">\(V^{\mathbb{B}}\)</span>-ランクに関する帰納法で定める：
<span class="math display">\[\begin{gathered}
         \left\| \sigma \in \tau \right\|_{\,} \mathrel{:=}
\sum_{\left\langle \vartheta, b \right\rangle \in \tau} \left\|
\vartheta = \sigma \right\|_{\,} \cdot b, \qquad
         \left\| \sigma = \tau \right\|_{\,} \mathrel{:=} \left\| \sigma
\subseteq \tau \right\|_{\,} \cdot \left\| \tau \subseteq \sigma
\right\|_{\,},\qquad
         \left\| \sigma \in \check{V} \right\|_{\,} \mathrel{:=} \sum_{x
\in V} \left\| \check{x} = \sigma \right\|_{\,},\\
         \text{where }
         \left\| \sigma \subseteq \tau \right\|_{\,} \mathrel{:=}
\prod_{\theta \in \mathrm{dom}(\sigma)} \left(- \left\| \theta \in
\sigma \right\|_{\,} + \left\| \theta \in \tau \right\|_{\,}\right).
        \end{gathered}\]</span></p></li>
<li><p>一般の<span class="math inline">\(\mathord{\mathcal{F\!L}}\)</span>-論理式<span class="math inline">\(\varphi[\vec{x}]\)</span>および<span class="math inline">\(\vec{\sigma} \in
V^{\mathbb{B}}\)</span>については，<span class="math inline">\(\varphi\)</span>の複雑性に関するメタレベルの帰納法で次のように定める：
<span class="math display">\[\begin{gathered}
         \left\| \varphi[\vec{\sigma}] \wedge
\psi[\vec{\sigma}]  \right\|_{\,} \mathrel{:=} \left\|
\varphi[\vec{\sigma}] \right\|_{\,} \cdot \left\| \psi[\vec{\sigma}]
\right\|_{\,}, \qquad
         \left\| \neg \varphi[\vec{\sigma}] \right\|_{\,} \mathrel{:=} -
\left\| \varphi[\vec{\sigma}] \right\|_{\,},\\
         \left\| \forall x \: \varphi[x, \vec{\sigma}] \right\|_{\,}
         \mathrel{:=} \prod_{\dot{x} \in V^{\mathbb{B}}} \left\|
\varphi[\dot{x}, \vec{\sigma}] \right\|_{\,}.
        \end{gathered}\]</span></p></li>
<li><p><span class="math inline">\(b \in
\mathbb{B}\)</span>に対し，<span class="sans-serif"><strong>強制関係</strong></span>を<span class="math inline">\(b \Vdash \varphi[\vec{\sigma}]
\xLeftrightarrow{\mathrm{def}} b \leq \left\| \varphi[\vec{\sigma}]
\right\|_{\,}\)</span>により定める．</p></li>
<li><p><span class="math inline">\(V^{\mathbb{B}} \models
\varphi[\vec{\sigma}]\)</span>は<span class="math inline">\(\left\|
\varphi[\vec{\sigma}] \right\|_{\,} =
\mathbb{1}\)</span>の略記とする．</p></li>
</ul>
</div>
<div class="remark">
<p>鋭い人は，上の真偽値の定義の<span class="math inline">\(\forall\)</span>の部分に違和感を覚えるかもしれません：
<span class="math display">\[\begin{aligned}
    \left\| \forall x \: \varphi[x, \vec{\sigma}] \right\|_{\,}
    \mathrel{:=} \prod_{\dot{x} \in V^{\mathbb{B}}} \left\|
\varphi[\dot{x}, \vec{\sigma}] \right\|_{\,}.
  \end{aligned}\]</span> というのもここで，<span class="math inline">\(\prod\)</span>が<span class="math inline">\(V^{\mathbb{B}}\)</span>という<span class="sans-serif"><strong>真のクラス</strong></span>を亘って取られているように見えるからです．
完備Boole代数では，<span class="math inline">\(\prod\)</span>や<span class="math inline">\(\sum\)</span>の範囲は<span class="sans-serif"><strong>集合</strong></span>に限定されていた筈だが，これは大丈夫なのか？と心配になるわけです．
しかし，ここで<span class="math inline">\(\prod\)</span>はあくまで<span class="math inline">\(\mathbb{B}\)</span>の<span class="sans-serif"><strong>特定の条件を満たす要素たち</strong></span>に対してとっており，<span class="math inline">\(\mathbb{B}\)</span>自体は<span class="sans-serif"><strong>集合</strong></span>ですので，最終的に下限が取られる対象も集合に収まるので問題はありません．</p>
<p>もう少し詳しく説明すると，以下のようになります． まず，上記の<span class="math inline">\(\prod_{\dot{x} \in V^{\mathbb{B}}} \left\|
\varphi[\dot{x}, \vec{\sigma}]
\right\|_{\,}\)</span>というのは以下の略記であったことを思い出しましょう：
<span class="math display">\[\begin{aligned}
    &amp;\prod_{\dot{x} \in V^{\mathbb{B}}} \left\| \varphi[\dot{x},
\vec{\sigma}] \right\|_{\,}\\
    &amp;= \prod \left\{\:  \left\| \varphi[\dot{x}, \vec{\sigma}]
\right\|_{\,}  \;\middle|\;  \dot{x} \in V^{\mathbb{B}} \:\right\}\\
    &amp;= \prod \left\{\:  b \in \mathbb{B}  \;\middle|\;  \exists
\dot{x} \in V^\mathbb{B} \: b = \left\| \varphi[\dot{x}, \sigma]
\right\|_{\,}  \:\right\}
  \end{aligned}\]</span> 最後の式で<span class="math inline">\(\prod\)</span>が取られているクラスは，ある論理式を満たす<span class="math inline">\(\mathbb{B}\)</span>の元の全体，という形で定義されています．
いま，<span class="math inline">\(\mathbb{B}\)</span>そのものは集合でしたから，<span class="sans-serif"><strong>分出公理</strong></span>よりこの形のクラスも集合であることが保証されます．
よって，<span class="math inline">\(\mathbb{B}\)</span>の完備性からその下限を取ることができ，無事定義がwell-definedになる訳です．</p>
<p>このように，<span class="math inline">\(\prod,
\sum\)</span>をとる際に使われるパラメータが真のクラスであっても，<span class="math inline">\(\mathbb{B}\)</span>が集合を成すことに気を付ければ自由に上限・下限を取ることができるので，以下気にせず取ってしまうことにします．</p>
</div>
<p>これにより，<span class="math inline">\(V^{\mathbb{B}}\)</span>において，強制法の論理式の解釈が<span class="math inline">\(\mathbb{B}\)</span>-真偽値として定まりました．</p>
<p>一つ注意しなくてはいけないのは，原子論理式に対する真偽値や<span class="math inline">\(\Vdash\)</span>は<span class="math inline">\(V\)</span>の中で一様に定義できていますが，一般の<span class="math inline">\(\varphi\)</span>についてはそうではない，ということです．
つまり，<span class="math inline">\(\left\| -
\right\|_{\,}\)</span>というのは関数スキーマであって，実際には<span class="math inline">\(\varphi \in
\mathord{\mathcal{F\!L}}\)</span>が決まる度に関数<span class="math inline">\(\left\| \varphi[-] \right\|_{\,}: V^\mathbb{B} \to
\mathbb{B}\)</span>という関数が個別に定義されている，ということです．
同様に，<span class="math inline">\(p \Vdash
\varphi[\sigma]\)</span>も<span class="math inline">\(\varphi\)</span>が決まるごとに，<span class="math inline">\(p\)</span>と<span class="math inline">\(\sigma\)</span>の間の二項関係が定義されている，ということになります．
これは，例えば自明なcBa <span class="math inline">\(\mathbf{2}\)</span>を考えると，<span class="math inline">\(V^{\mathbf{2}} \simeq
V\)</span>となってしまい，<span class="math inline">\(V \models \varphi
\iff \left\| \varphi \right\|_{\,\mathbf{2}} =
\mathbb{1}\)</span>となりますが，もしこれが<span class="math inline">\(\varphi\)</span>の関数として<span class="math inline">\(V\)</span>の中で定義出来たとすれば，<span class="math inline">\(V\)</span>の真理述語が定義出来たことになり，Tarskiの真理定義不可能性に反します．</p>
<p>こうして広げた<span class="math inline">\(V^{\mathbb{B}}\)</span>は，常に集合論のモデルとなります：</p>
<div class="theorem">
<p><span class="math inline">\(V^{\mathbb{B}} \models
\mathrm{ZFC}\)</span>. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
</div>
<p>これも，厳密には<span class="sans-serif"><strong>定理スキーマ</strong></span>です．
つまり，<span class="math inline">\(\mathrm{ZFC}\)</span>の各公理<span class="math inline">\(\varphi\)</span>について，<span class="math inline">\(\left\| \varphi \right\|_{\,\mathbb{B}} =
\mathbb{1}\)</span>となることが個別に示せる，ということです．</p>
<p>さて，強制法論理式では<span class="math inline">\(\check{V}\)</span>という述語記号を定義しましたが，ちゃんとこれが真偽も含めて<span class="math inline">\(V^{\mathbb{B}}\)</span>における<span class="math inline">\(V\)</span>の写し身になっている，というのが次の二つの定理です：</p>
<div class="theorem">
<p><a href id="thm:V-truth-emb-generic"></a> 集合論の論理式<span class="math inline">\(\varphi[x_1, \dots, x_n]\)</span>と<span class="math inline">\(a_1, \dots, a_n \in V\)</span>に対し， <span class="math display">\[V \models \varphi[a_1, \dots, a_n] \iff
V^{\mathbb{B}} \models \varphi^{\check{V}}[\check{a}_1, \dots,
\check{a}_n].\]</span> 但し，<span class="math inline">\(\varphi^{\check{V}}\)</span>は<span class="math inline">\(\varphi\)</span>に現れる量化子<span class="math inline">\(\exists x\)</span>, <span class="math inline">\(\forall x\)</span>を全て<span class="math inline">\(\exists x \: \check{V}(x) \wedge
\dots\)</span>および<span class="math inline">\(\forall x \:
\check{V}(x) \to \dots\)</span>で置き換えた<span class="math inline">\(\mathord{\mathcal{F\!L}}\)</span>-論理式．</p>
</div>
<div class="theorem">
<p><a href id="thm:V-check-inner-model"></a> <span class="math inline">\(V^{\mathbb{B}} \models \text{“}\check{V}:
\text{推移的}, \mathord{\mathrm{On}} \subseteq
\check{V}\text{”}\)</span>.</p>
</div>
<p>従って，<span class="math inline">\(V\)</span>は<span class="math inline">\(V^{\mathbb{B}}\)</span>に埋め込まれていると見てよい話です．
<span class="math inline">\(V^{\mathbb{B}}\)</span>は<span class="math inline">\(V\)</span>と順序数も共通しているので，高さが同じで，幅を横に広げてやったものと思えます．
これから色々な命題の独立性を調べていくにあたって，その際にどういった性質が強制拡大で保たれるのかが気になります．
上の二つの定理から，次のような手頃な判断基準が得られます：</p>
<div class="theorem">
<p>推移的モデルについて絶対的な概念は，強制概念で動かない． 特に<span class="math inline">\(\Delta_1\)</span>-概念は強制法的に絶対．
特に，有限集合，<span class="math inline">\(\omega\)</span>である，関数である，順序数である，といった性質は動かない．</p>
</div>
<p>「推移的モデルについて絶対的な概念」の具体例については，たとえばこのサイトの「<a href="https://konn-san.com/math/absoluteness-cheatsheet.html">絶対性チートシート</a>」<span class="citation"><a href="#ref-Ishii:2016db" role="doc-biblioref"> [3]</a></span>を御覧ください．</p>
<p>さて，<span class="math inline">\(V^{\mathbb{B}}\)</span>という物を考えたのは，<span class="math inline">\(V\)</span>にはない元を付加するためでした．
それが<span class="sans-serif"><strong>ジェネリックフィルター</strong></span>です．</p>
<div class="definition">
<ul>
<li><p>擬順序集合<span class="math inline">\(\mathbb{P}\)</span>について，<span class="math inline">\(F \subseteq \mathbb{P}\)</span>が<span class="math inline">\(\mathbb{P}\)</span>上のフィルター<span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span> <span class="math inline">\(\emptyset \neq F \subsetneq \mathbb{P}\)</span>,
<span class="math inline">\(x \geq y \in F \implies x \in F\)</span>,
<span class="math inline">\(x, y \in F \implies \exists z \in F \: z
\leq x, y\)</span>.</p></li>
<li><p><span class="math inline">\(p \in \mathbb{P}\)</span>が<span class="sans-serif"><strong>アトム</strong></span><span class="math inline">\(\xLeftrightarrow{\mathrm{def}} \forall r, s \leq
p\: r \mathrel{\|} s\)</span>.</p></li>
<li><p>フィルター<span class="math inline">\(F \subseteq
\mathbb{P}\)</span>が<span class="sans-serif"><strong>超フィルター</strong></span><span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span> <span class="math inline">\(F\)</span>は極大.</p></li>
<li><p><span class="math inline">\(D \subseteq
\mathbb{P}\)</span>が<span class="math inline">\(\mathbb{P}\)</span>で<span class="sans-serif"><strong>稠密</strong></span><span class="math inline">\(\xLeftrightarrow{\mathrm{def}} \forall x \in
\mathbb{P} \: \exists y \in D \: y \leq x\)</span>.</p></li>
<li><p><span class="math inline">\(M\)</span>を何らかのクラスとする．
<span class="math inline">\(G \subseteq \mathbb{B}\)</span>が<span class="sans-serif"><strong><span class="math inline">\(M\)</span>上の<span class="math inline">\(\mathbb{B}\)</span>-ジェネリックフィルター</strong></span></p>
<p><span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span>
<span class="math inline">\(G\)</span>はフィルターであり，<span class="math inline">\(\forall D \in M: \mathbb{B}\text{で稠密}\: D \cap
G \neq \emptyset\)</span>.</p></li>
<li><p><span class="math inline">\(\dot{G} \mathrel{:=} \left\{\:
\left\langle \check{b}, b \right\rangle  \;\middle|\;  b \in \mathbb{B}
\:\right\} \in V^{\mathbb{B}}\)</span>を<span class="sans-serif"><strong><span class="math inline">\(\mathbb{B}\)</span>のジェネリックフィルターの標準的名称</strong></span>と呼ぶ．</p></li>
</ul>
</div>
<p>上のジェネリックフィルターこそ，我々が<span class="math inline">\(V\)</span>に追加したかった「新しい元」「理想元」です．
<span class="math inline">\(V^{\mathbb{B}}\)</span>の各元は完備Boole代数<span class="math inline">\(\mathbb{B}\)</span>-値の所属確率を持つ元だと思えた訳ですが，逆に<span class="math inline">\(\mathbb{B}\)</span>の各元はこのジェネリックフィルター<span class="math inline">\(G\)</span>の〈近似〉だと思うことが出来るのです．
より詳しく，<span class="math inline">\(\mathbb{B}\)</span>上の順序は，各元の<span class="math inline">\(G\)</span>の近似として自由度について並べられていると考えることが出来，<span class="math inline">\(q \leq p\)</span>は「<span class="math inline">\(q\)</span>は<span class="math inline">\(p\)</span>を拡張する近似」「<span class="math inline">\(q\)</span>は<span class="math inline">\(p\)</span>より精しい近似」「<span class="math inline">\(p\)</span>の方が<span class="math inline">\(q\)</span>より自由度がある」と読むことが出来ます．
この見方は，のちほど第 <a href="#sec:forcing-general">2</a>節で擬順序に一般化した際にも通用します．</p>
<p>なぜこう思えるのでしょうか？
それは，まず第一にはフィルターの定義を見てみるとわかります．
フィルターというのは，<span class="sans-serif"><strong>貼り合わせられる近似の集合</strong></span>だと思えるのです．
特に，<span class="math inline">\(F\)</span>が下界について閉じているという条件が一番の本質です．
<span class="math inline">\(\leq\)</span>が近似の精しさを表していると思った時，<span class="math inline">\(r \leq p, q\)</span>を満たす<span class="math inline">\(r\)</span>は，二つの近似<span class="math inline">\(p\)</span>, <span class="math inline">\(q\)</span>両方の情報を持った，いわば両者を<span class="sans-serif"><strong>貼り合わせた</strong></span>ものだと思えます．
フィルター<span class="math inline">\(F\)</span>が下界を取る操作で閉じている，ということは，<span class="math inline">\(F\)</span>が捉えている近似はいくらでも貼り合わせて精しく出来る，という事を意味します．
そこに加えて，「超フィルターである」ということ，つまり極大なフィルターであるという事は，「貼り合わせが可能なギリギリの範囲まで集めてきた」ものだと思える訳で，それはつまり「近似を貼り合わせて得られるホンモノの対象」に対応していそうです．</p>
<p>今一実感が湧きづらいかもしれないので，実例を見てみましょう．
単位区間<span class="math inline">\([0,1]\)</span>に属する実数は，二進無限小数展開を通じて<span class="math inline">\(\left\{ 0, 1
\right\}\)</span>の無限列だと思うことが出来ます．
この時，実数の有限桁の近似全体<span class="math inline">\({}^{&lt;\omega} {2}\)</span>に<span class="math inline">\(p \leq q \xLeftrightarrow{\mathrm{def}} p
\supseteq q\)</span>という順序を入れましょう．
すると，この順序での超フィルター<span class="math inline">\(U\)</span>を考えたとき，<span class="math inline">\(U\)</span>の各元を貼り合わせて得られる<span class="math inline">\(\bigcup U\)</span>は，<span class="math inline">\(\left\{ 0, 1
\right\}\)</span>の無限列となり，一つの実数に対応することがわかります．
逆に，実数<span class="math inline">\(x : \omega \to
2\)</span>が与えられれば，これらの最初の有限桁の近似ぜんぶを持ってくれば，これが<span class="math inline">\(({}^{&lt;\omega} {2},
\supseteq)\)</span>の超フィルターとなることもすぐにわかります．</p>
<p>もちろん，超フィルターは選択公理させあればいつでも取れる訳で，単なる超フィルターである，という条件だけではまだ理想元であるとはいえません．
「理想元である」という事を捕まえているのが，ジェネリック性の「<span class="math inline">\(M\)</span>に属する稠密集合と必ず交わる」という条件です．
<span class="math inline">\(D\)</span>が<span class="math inline">\(M\)</span>で稠密である，ということは，いいかえれば「どんな近似も，適切に拡張することで性質<span class="math inline">\(D\)</span>を満たすようにできる」という事です．
また，cBaの場合に計算してみれば，<span class="math inline">\(D\)</span>が稠密ならその上限は<span class="math inline">\(\sum D =
\mathbb{1}\)</span>となることもわかります． つまり，「<span class="math inline">\(D\)</span>が稠密である」という事はのは，<span class="math inline">\(\mathbb{B}\)</span>の意味で「性質<span class="math inline">\(D\)</span>はほぼ確率<span class="math inline">\(\mathbb{1}\)</span>で成り立つ」であると思える訳です．
これを踏まえれば，ジェネリック性は「<span class="math inline">\(M\)</span>で捕まえられるような，<span class="math inline">\(\mathbb{B}\)</span>の各元が普遍的に満たすような性質は，それらを貼り合わせて得られる理想元<span class="math inline">\(G\)</span>も満たしている」という意味に解釈出来る訳です．</p>
<p>では，この<span class="math inline">\(G\)</span>は本当に新しい元になっているのでしょうか？
たとえば，<span class="math inline">\(\mathbb{B}\)</span>が<span class="math inline">\(G\)</span>の〈近似〉としては自明な元を含む場合，には<span class="math inline">\(G\)</span>がもともと<span class="math inline">\(V\)</span>の元であった，といったことは起きそうです．
自明な近似，というのは，「それより延ばしようがない」あるいは「それから先の延ばし方が一通りしかない」ような近似で，といっても構いません．
そのような「一番精しい近似」とでもいうべきものが，上で最後に定義した<span class="sans-serif"><strong>アトム</strong></span>の概念です．
では，アトムを持たないようなcBaであれば，ジェネリックフィルターは<span class="math inline">\(V\)</span>の属さない本当に「新しい元」になっているのではないか？
実際そうだ，というのが次の定理です：</p>
<div class="theorem">
<p><span class="math inline">\(\mathbb{B}\)</span>がアトムを持たないなら，<span class="math inline">\(V\)</span>上の<span class="math inline">\(\mathbb{B}\)</span>-ジェネリックフィルターは<span class="math inline">\(V\)</span>に存在しない．</p>
</div>
<div class="proof">
<p><em>Proof.</em> まず，<span class="math inline">\(\mathbb{B}\)</span>がアトムを持たない場合，一般に<span class="math inline">\(\mathbb{B}\)</span>上のフィルター<span class="math inline">\(F\)</span>に対し，<span class="math inline">\(D
\mathrel{:=} \mathbb{B} \setminus F\)</span>は稠密集合となることを示す．
<span class="math inline">\(x \in \mathbb{B}\)</span>を取れば，<span class="math inline">\(p, q \leq x\)</span>で<span class="math inline">\(p \cdot q = 0\)</span>を満たすものが存在する．
すると，<span class="math inline">\(F\)</span>がフィルターである事から，<span class="math inline">\(p, q\)</span>の少なくとも一方は<span class="math inline">\(F\)</span>に属さない事がわかる． 従って<span class="math inline">\(p \in D\)</span>または<span class="math inline">\(q \in
D\)</span>のいずれか一方のみが成り立たなくてはならない． <span class="math inline">\(x\)</span>の選択は任意であったから，<span class="math inline">\(D\)</span>は<span class="math inline">\(\mathbb{B}\)</span>で稠密である．</p>
<p>以上を踏まえれば，もしジェネリックフィルター<span class="math inline">\(G\)</span>が<span class="math inline">\(V\)</span>に属したとすると，<span class="math inline">\(D \mathrel{:=} \mathbb{B} \setminus G \in
V\)</span>は稠密集合となり，<span class="math inline">\(D \cap G \neq
\emptyset\)</span>となってしまうが，これは矛盾である．</p>
</div>
<p>よって，十分複雑な<span class="math inline">\(\mathbb{B}\)</span>についてはジェネリックフィルターは非自明なものであることがわかりました．
このことから，次の補題により，「新しい元」が<span class="math inline">\(V^{\mathbb{B}}\)</span>に付け加わっていると思うことが出来ます：</p>
<div class="theorem">
<p><span class="math inline">\(V^{\mathbb{B}} \models \text{“}\dot{G}:
\check{V}\text{上
}\check{\mathbb{B}}\text{-ジェネリック}\text{”}\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> 定義から<span class="math inline">\(\displaystyle
\left\| \check{b} \in \dot{G} \right\|_{\,} = \sum_{c \in \mathbb{B}}
\left\| \check{c} = \check{b} \right\|_{\,} \cdot c =
b\)</span>となる事に注意する． すると，<span class="math inline">\(V^{\mathbb{B}} \Vdash \check{\mathbb{1}} \in
\dot{G}, \check{0} \notin \dot{G}\)</span>はすぐにわかる．
上に閉じていることも， <span class="math display">\[\left\| \check{b}
\leq \check{c} \wedge \check{b} \in \dot{G} \implies \check{c} \in
\dot{G} \right\|_{\,} = - (\left\| \check{b} \leq \check{c}
\right\|_{\,} \cdot \left\| \check{b} \in \dot{G} \right\|_{\,}) +
\left\| \check{c} \in \dot{G} \right\|_{\,}
= - (\left\| \check{b} \leq \check{c} \right\|_{\,} \cdot b) + c =
\mathbb{1}.\]</span> また，<span class="math inline">\(\left\| \check{b
\cdot c} = (\check{b} \cdot \check{c}) \in \dot{G} \right\|_{\,} = b
\cdot c = \left\| \check{b} \in \dot{G} \wedge \check{c} \in \dot{G}
\right\|_{\,}\)</span>より<span class="math inline">\(\dot{G}\)</span>の任意の二元は両立する．
よって<span class="math inline">\(\dot{G}\)</span>はフィルターである．
更に，<span class="math inline">\(\left\| \check{b} \notin \dot{G}
\right\|_{\,} = - \left\| \check{b} \in \dot{G} \right\|_{\,} = - b =
\left\| -\check{b} \in \dot{G} \right\|_{\,}\)</span>なので，<span class="math inline">\(\dot{G}\)</span>は超フィルターでもある．</p>
<p>最後に，<span class="math inline">\(D \in
V\)</span>を稠密集合とすると， <span class="math display">\[\left\|
\check{D} \cap \dot{G} \neq \emptyset \right\|_{\,} =
\left\| \exists x \in \check{D} \: x \in \dot{G} \right\|_{\,} = \sum_{d
\in D} \left\| d \in \dot{G} \right\|_{\,} = \sum D =
\mathbb{1}.\]</span> よって<span class="math inline">\(V^{\mathbb{B}}
\models \text{“}\dot{G}: V\text{ 上
}\mathbb{B}\text{-ジェネリック}\text{”}\)</span>.</p>
</div>
<p>このようにして，<span class="math inline">\(V^{\mathbb{B}}\)</span>の中では，<span class="math inline">\(V\)</span>に存在しないジェネリックフィルターが存在しているかのように見えていることがわかりました．
更に，実は<span class="math inline">\(V^{\mathbb{B}}\)</span>は自分が<span class="math inline">\(\check{V}\)</span>と<span class="math inline">\(\dot{G}\)</span>を含む最小の<span class="math inline">\(\mathrm{ZFC}\)</span>のモデルであると信じている事もわかります．</p>
<p>それを述べるには，次のような定義が必要になります：</p>
<div class="definition">
<ul>
<li><p><span class="math inline">\(F\)</span>を<span class="math inline">\(\mathbb{B}\)</span>のフィルターとする． <span class="math inline">\(\mathbb{B}\)</span>-name <span class="math inline">\(\tau\)</span>の<span class="math inline">\(F\)</span>-<span class="sans-serif"><strong>解釈</strong></span><span class="math inline">\(\tau^F \mathrel{:=} \mathop{\mathrm{val}}(\tau,
F)\)</span>を帰納的に次のように定める： <span class="math display">\[\mathop{\mathrm{val}}(\tau, F) \mathrel{:=}
\left\{\:  \mathop{\mathrm{val}}(\sigma, F)  \;\middle|\;  (\sigma, b)
\in \tau, b \in F \:\right\}.\]</span></p></li>
<li><p><span class="math inline">\(M\)</span>を推移的な集合論のモデルとし，<span class="math inline">\(\mathbb{B} \in M\)</span>をcBaとする． <span class="math inline">\(M\)</span>上の<span class="math inline">\(\mathbb{B}\)</span>-ジェネリックフィルター<span class="math inline">\(G\)</span>に対し，<span class="math inline">\(M\)</span>の<span class="math inline">\(G\)</span>による<span class="sans-serif"><strong>ジェネリック拡大</strong></span><span class="math inline">\(M[G]\)</span>を次で定める： <span class="math display">\[M[G] \mathrel{:=} \left\{\:
\sigma^G  \;\middle|\;  \sigma \in M^{\mathbb{B}}
\:\right\}.\]</span></p></li>
</ul>
</div>
<div class="lemma">
<p><span class="math inline">\(M[G]\)</span>は<span class="math inline">\(M \subseteq N\)</span>と<span class="math inline">\(G \in N\)</span>を満たす推移的モデル<span class="math inline">\(N\)</span>の中で最小．</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(N\)</span>が推移的で<span class="math inline">\(M \subseteq N\)</span>かつ<span class="math inline">\(G \in N\)</span>なら<span class="math inline">\(M^{\mathbb{B}} \subseteq
N\)</span>となることは明らか． <span class="math inline">\(\mathop{\mathrm{val}}\)</span>の値も明らかに推移的モデルについては絶対的なので，<span class="math inline">\(M[G] \subseteq N\)</span>となる．</p>
</div>
<div class="theorem">
<p>任意の<span class="math inline">\(\tau \in
V^{\mathbb{B}}\)</span>に対し，<span class="math inline">\(V^{\mathbb{B}} \models \tau =
\check{\tau}^{\dot{G}}\)</span>.</p>
<p>よって<span class="math inline">\(V^{\mathbb{B}} \models \forall x \:
x \in \check{V}[\dot{G}]\)</span>が成り立ち，<span class="math inline">\(V^{\mathbb{B}}\)</span>は自分自身の事を<span class="math inline">\(\check{V}[\dot{G}]\)</span>だと思い込んでいる．</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(\tau\)</span>のランクに関する帰納法．</p>
</div>
<span class="img-fluid"><object class="img-thumbnail media-object" type="image/svg+xml" data="/math/boolean-valued-model-and-forcing/image-0.svg"><img src="/math/boolean-valued-model-and-forcing/image-0.png" alt="Diagram"></object></span>
<p>よって以上から，<span class="math inline">\(V^{\mathbb{B}}\)</span>を<span class="math inline">\(V[G]\)</span>と同一視して，あたかも<span class="math inline">\(V\)</span>上のジェネリックフィルター<span class="math inline">\(G\)</span>が取れているかのように考えても差し支えないということがわかります．
このような見方の下で，<span class="math inline">\(V\)</span>と<span class="math inline">\(V[G]\)</span>は，右図のような形をしています．</p>
</section>
<section id="sec:forcing-general" class="level1">
<h2>強制法の一般論へ</h2>
<p>以上の理論はcBaについて構築してきましたが，実用上は<span class="sans-serif"><strong>擬順序集合</strong></span>による強制法を考えるのが便利です．</p>
<div class="definition">
<ul>
<li><p><span class="math inline">\(\left\langle \mathbb{P}, \leq,
\mathbb{1} \right\rangle\)</span>が<span class="sans-serif"><strong>擬順序集合</strong></span>（<em>poset</em>）
<span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span>
<span class="math inline">\(\leq\)</span>は<span class="math inline">\(\mathbb{P}\)</span>上反射的かつ推移的であり，<span class="math inline">\(\mathbb{1}\)</span>はその最大元．</p></li>
<li><p><span class="math inline">\(p \mathrel{\|} q
\xLeftrightarrow{\mathrm{def}} \exists r \in \mathbb{P} \: r \leq p,
q\)</span>.</p></li>
<li><p><span class="math inline">\(p \perp q
\xLeftrightarrow{\mathrm{def}} \neg (p \mathrel{\|}
q)\)</span>.</p></li>
</ul>
</div>
<p>問題は，cBaで量化子を解釈する際には無限演算<span class="math inline">\(\prod\)</span>, <span class="math inline">\(\sum\)</span>が使えたのに対し，posetの場合はそう素直にいかない事です．
そこで，posetによる強制法を考える場合には，真偽値<span class="math inline">\(\left\| \quad
\right\|_{\,}\)</span>ではなく強制関係<span class="math inline">\(\Vdash\)</span>を基本的な関係として考えます．</p>
<p>まず，簡単な計算により，cBaの場合は<span class="math inline">\(\Vdash\)</span>が次を満たすことがわかります：</p>
<div class="lemma">
<p><span class="math inline">\(\varphi,
\psi\)</span>を強制法の論理式とする．</p>
<ul>
<li><p><span class="math inline">\(p \Vdash \sigma \in \tau \iff
\left\{\:  q \leq p  \;\middle|\;  \exists \left\langle s, \theta
\right\rangle \in \tau \: q \leq s, q \Vdash \sigma = \theta
\:\right\}\)</span>が<span class="math inline">\(p\)</span>以下で稠密．</p></li>
<li><p><span class="math inline">\(p \Vdash \sigma = \tau \iff \forall
\vartheta \in \mathrm{dom}(\sigma) \cup \mathrm{dom}(\tau)\:\forall q
\leq p \: [ q \Vdash \text{“}\vartheta \in \sigma\text{”} \iff q \Vdash
\text{“}\vartheta \in \tau\text{”} ]\)</span>.</p></li>
<li><p><span class="math inline">\(p \Vdash \varphi \wedge \psi \iff  p
\Vdash \varphi\)</span>かつ<span class="math inline">\(p \Vdash
\psi\)</span>.</p></li>
<li><p><span class="math inline">\(p \Vdash \neg \varphi \iff \left\{\:
q  \;\middle|\;  q \not\Vdash \varphi \:\right\}\)</span>が<span class="math inline">\(p\)</span>以下で稠密.</p></li>
<li><p><span class="math inline">\(p \Vdash \forall x \varphi(x) \iff
\forall \sigma \in V^{\mathbb{P}} \: p \Vdash
\varphi(\sigma)\)</span>.</p></li>
</ul>
</div>
<p>そこで，一般のposetの場合はこれを逆に定義として採用してしまいましょう．</p>
<div class="definition">
<p>Poset <span class="math inline">\(\mathbb{P}\)</span>と<span class="math inline">\(\varphi \in
\mathord{\mathcal{F\!L}}\)</span>および<span class="math inline">\(p \in
\mathbb{P}\)</span>に対して，<span class="math inline">\(p
\Vdash_{\mathbb{P}} \varphi\)</span>を上の補題の各条件で定義する．</p>
<p>また<span class="math inline">\(V^{\mathbb{P}} \models
\varphi\)</span>は<span class="math inline">\(\mathbb{1}
\Vdash_{\mathbb{P}} \varphi\)</span>の略記とする．</p>
</div>
<p>これで形だけは定義出来た訳ですが，果してBoole値モデルとちゃんと対応してくれるでしょうか？
それを見るためには，posetの埋め込みと完備化についての理論が必要になります．</p>
<div class="definition">
<ul>
<li><p>以下の三条件を満たすとき，<span class="math inline">\(i:
\mathbb{P} \to \mathbb{Q}\)</span>は<span class="sans-serif"><strong>稠密埋め込み</strong></span>という：</p>
<ol>
<li><p><span class="math inline">\(i(\mathbb{1}_{\mathbb P}) =
\mathbb{1}_{\mathbb{Q}}\)</span>.</p></li>
<li><p><span class="math inline">\(p \leq_{\mathbb{P}} q \implies i(p)
\leq_{\mathbb{Q}} i(q)\)</span>,</p></li>
<li><p><span class="math inline">\(p \mathrel{\|} q \iff i(p)
\mathrel{\|} i(q)\)</span>,</p></li>
<li><p><span class="math inline">\(i[\mathbb{P}]\)</span>は<span class="math inline">\(\mathbb{Q}\)</span>で稠密．</p></li>
</ol></li>
<li><p><span class="math inline">\(i: \mathbb{P} \to
\mathbb{B}\)</span>が<span class="math inline">\(\mathbb{P}\)</span>の<span class="sans-serif"><strong>Boole完備化</strong></span><span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span> <span class="math inline">\(\mathop{\mathrm{ran}}(i) \subseteq \mathbb{B}
\setminus \left\{ 0 \right\}\)</span>であり<span class="math inline">\(i\)</span>は稠密．</p></li>
</ul>
</div>
<p>順序集合の一般論により，次が言えます：</p>
<div class="fact">
<p>任意のposet <span class="math inline">\(\mathbb{P}\)</span>に対し，そのBoole完備化<span class="math inline">\(\mathbb{B} =
\mathbb{B}(\mathbb{P})\)</span>が同型を除いて一意に存在する．
特に，<span class="math inline">\(\mathbb{P}\)</span>の擬順序位相に関する正則開集合代数はその一つ．</p>
</div>
<p>これらから，我々は<span class="math inline">\(\mathbb{P}\)</span>による強制法と，<span class="math inline">\(\mathbb{B}(\mathbb{P})\)</span>によるBoole値モデルの二つの方法を得た訳です．
これらの関係を与えるのが次の補題です：</p>
<div class="lemma">
<p><span class="math inline">\(i: \mathbb{P} \to
\mathbb{Q}\)</span>を稠密埋め込みとする． この時，<span class="math inline">\(\tilde{\imath}: \mathop{\mathcal{P}}(\mathbb{P})
\to \mathop{\mathcal{P}}(\mathbb{Q})\)</span>および<span class="math inline">\(i^*: V^{\mathbb{P}} \to
V^{\mathbb{Q}}\)</span>を次で定める： <span class="math display">\[\begin{aligned}
  \tilde{\imath}(A) &amp;\mathrel{:=} \left\{\: q \in
\mathbb{Q}  \;\middle|\;  \exists p \in A \: i(p) \leq_{\mathbb{Q}} q
\:\right\},\\
  i^*(\sigma) &amp; \mathrel{:=} \left\{\: \left\langle i^*(\tau), i(p)
\right\rangle  \;\middle|\;  \left\langle \tau, p \right\rangle \in
\sigma \:\right\},\\
  i_*(\sigma) &amp; \mathrel{:=} \left\{\: \left\langle i_*(\tau), p
\right\rangle  \;\middle|\;  \left\langle \tau, q \right\rangle \in
\sigma, i(p) \leq q \:\right\}.
\end{aligned}\]</span></p>
<ul>
<li><p><span class="math inline">\(V^{\mathbb{P}} \models \sigma =
i_*(i^*(\sigma))\)</span>, <span class="math inline">\(V^{\mathbb{Q}}
\models \sigma = i^*(i_*(\sigma))\)</span>.</p></li>
<li><p><span class="math inline">\(G\)</span>が<span class="math inline">\(\mathbb{P}\)</span>-ジェネリックなら<span class="math inline">\(H \mathrel{:=} \tilde{\imath}(G)\)</span>は<span class="math inline">\(\mathbb{Q}\)</span>-ジェネリックで<span class="math inline">\(V[G] = V[H]\)</span>.</p></li>
<li><p><span class="math inline">\(H\)</span>が<span class="math inline">\(\mathbb{Q}\)</span>-ジェネリックなら<span class="math inline">\(G \mathrel{:=} i^{-1}[H]\)</span>は<span class="math inline">\(\mathbb{P}\)</span>-ジェネリックで<span class="math inline">\(V[H] = V[G]\)</span>.</p></li>
<li><p><span class="math inline">\(p \Vdash_{\mathbb{P}}
\varphi[\sigma_1, \dots, \sigma_n] \iff i(p) \Vdash_{\mathbb Q}
\varphi[i^*(\sigma_1), \dots, i^*(\sigma_n)]\)</span>.</p></li>
</ul>
</div>
<p>つまり，二つのposetの間に稠密埋め込みが存在した場合，それらは強制法としては同値になるのです．
特に，<span class="math inline">\(\mathbb{P}\)</span>による強制と，<span class="math inline">\(\mathbb{B} =
\mathbb{B}(\mathbb{P})\)</span>による強制とで結果は変わらない事がわかります．
<span class="math inline">\(\mathbb{B}\)</span>の方が見掛け上の真偽値が多く<span class="math inline">\(V^{\mathbb{B}}\)</span>も大きく見えますが，表現出来る集合の数は本質的に<span class="math inline">\(V^{\mathbb{P}}\)</span>と変わっていない訳です．</p>
<section id="強制関係vdashの基本性質" class="level2">
<h3>強制関係<span class="math inline">\(\Vdash\)</span>の基本性質</h3>
<p>Boole値モデルの場合は<span class="math inline">\(\mathbb{B}\)</span>の各元は真偽値の集合と思った訳ですが，posetの場合は<span class="math inline">\(\mathbb{P}\)</span>の各元は<span class="sans-serif"><strong>ジェネリックオブジェクトの近似</strong></span>だと思って，<span class="math inline">\(p \Vdash \varphi\)</span>は「近似<span class="math inline">\(p\)</span>の下で<span class="math inline">\(\varphi\)</span>が成立する」と読むのがわかりやすいでしょう．</p>
<p>Posetの場合は真偽値の計算は出来ませんが，強制関係の計算によって何が成り立つのかを調べる事が出来ます．
そうした計算上で，次の補題はよく使われます：</p>
<div class="lemma">
<p><a href id="lem:aux-lem"></a></p>
<ul>
<li><p><span class="math inline">\(p \Vdash \varphi \iff \left\{\:
q  \;\middle|\;  q \Vdash \varphi \:\right\}\)</span>が<span class="math inline">\(p\)</span>以下で稠密．</p></li>
<li><p><span class="math inline">\(p \Vdash \exists x \in \check{a}\:
\varphi(x) \iff \left\{\: q  \;\middle|\;  \exists a \: p \Vdash
\varphi(\check{a}) \:\right\}\)</span>が<span class="math inline">\(p\)</span>以下で稠密．</p></li>
<li><p>任意の<span class="math inline">\(\varphi\)</span>と<span class="math inline">\(p \in \mathbb{P}\)</span>に対し， <span class="math inline">\(\exists q \leq p\: (q \Vdash \varphi) \vee (q
\Vdash \neg \varphi)\)</span>.</p></li>
<li><p><span class="math inline">\(V[G] \models \varphi \iff \exists p
\in G\: p \Vdash \varphi\)</span>.</p></li>
</ul>
</div>
</section>
</section>
<section id="連続体仮説の独立性" class="level1">
<h2>連続体仮説の独立性</h2>
<p>これらを使って，連続体仮説の独立性を証明したいと思います．</p>
<div class="definition">
<ul>
<li><p><span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)
\mathrel{:=} ({}^{&lt;\kappa} {2}, \supseteq)\)</span>を<span class="sans-serif"><strong><span class="math inline">\(\kappa\)</span>の部分集合を付け足すposet</strong></span>と呼ぶ．</p></li>
<li><p>基数<span class="math inline">\(\kappa\)</span>について，posets
<span class="math inline">\(\left\langle\: (\mathbb{P}_i, \leq_i,
\mathbb{1}_i)  \; \middle|\;  i \in I \:\right\rangle\)</span>の<span class="sans-serif"><strong><span class="math inline">\(\kappa\)</span>-台直積</strong></span>を次で定める：
<span class="math display">\[\begin{gathered}
         \prod_{i \in I}^{&lt;\kappa} \mathbb{P}_i \mathrel{:=}
\left\{\:  p : \text{function}  \;\middle|\;  \mathrm{dom}(p) \in
[I]^{&lt;\kappa}, \forall i \in \mathrm{dom}(p)\: p(i) \in \mathbb{P}_i
\:\right\},\\
         \mathbb{1} \mathrel{:=} \emptyset,\\
         p \leq q \xLeftrightarrow{\mathrm{def}} \mathrm{dom}(p)
\supseteq \mathrm{dom}(q) \wedge \forall i \in \mathrm{dom}(p)\: p(i)
\leq_i q(i).
        \end{gathered}\]</span></p></li>
<li><p><span class="math inline">\(\mathop{\mathsf{Add}}(\kappa, \gamma)
\mathrel{:=} \prod_{\alpha &lt; \gamma}^{&lt; \kappa}
\mathop{\mathsf{Add}}(\kappa)\)</span>を<span class="sans-serif"><strong><span class="math inline">\(\kappa\)</span>の部分集合を<span class="math inline">\(\gamma\)</span>個付け加えるposet</strong></span>と呼ぶ．</p></li>
</ul>
</div>
<p>次でみるように，<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>は，<span class="math inline">\(\kappa\)</span>から<span class="math inline">\(2\)</span>への関数を付加するので，特性関数だと思えば確かに<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>は新たな<span class="math inline">\(\kappa\)</span>の部分集合を付け足していると言える．</p>
<div class="lemma">
<p><span class="math inline">\(G\)</span>を<span class="math inline">\(V\)</span>上の<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>-ジェネリックフィルターとすると，<span class="math inline">\(V[G] \models \bigcup\dot{G}: \kappa \to
2\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> まず<span class="math inline">\(G\)</span>がフィルターであり，特に任意の二元が両立することから，<span class="math inline">\(\bigcup G\)</span>は関数となることに注意する．</p>
<p>なので，あとは<span class="math inline">\(\bigcup G\)</span>が<span class="math inline">\(\kappa\)</span>全域で定義されている事をみればよい．
ここで，以下の形の集合は<span class="math inline">\(V\)</span>に属する<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>の稠密集合である：
<span class="math display">\[D_\alpha \mathrel{:=} \left\{\: p \in
\mathop{\mathsf{Add}}(\kappa)  \;\middle|\;  \alpha \in \mathrm{dom}(p)
\:\right\}\;(\alpha &lt; \kappa)\]</span> よって，各<span class="math inline">\(\alpha &lt; \kappa\)</span>について<span class="math inline">\(G \cap D_\alpha \neq \emptyset\)</span>.
以上より<span class="math inline">\(\kappa = \mathrm{dom}(\bigcup
G)\)</span>.</p>
</div>
<p><span class="math inline">\(\kappa\)</span>が正則基数のとき<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>の組合せ論的性質として，次が成り立つことがわかる：</p>
<div class="definition">
<p>Poset <span class="math inline">\(\mathbb{P}\)</span>が<span class="sans-serif"><strong><span class="math inline">\(\gamma\)</span>-閉</strong></span><span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span>任意の<span class="math inline">\(\alpha &lt; \gamma\)</span>と降鎖<span class="math inline">\(\left\langle\: p_\beta  \; \middle|\;  \beta &lt;
\alpha \:\right\rangle\)</span>（<span class="math inline">\(\beta &lt;
\xi \implies p_\beta \leq p_\xi\)</span>）に対し，下界<span class="math inline">\(p^*\)</span>が存在：<span class="math inline">\(\forall \beta &lt; \alpha\: p^* \leq
p_\beta\)</span>.</p>
</div>
<div class="lemma">
<p><span class="math inline">\(\kappa\)</span>が正則の時，<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>および<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa,
\gamma)\)</span>は<span class="math inline">\(\mathrm{cf}(\kappa)\)</span>-閉.</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(\gamma &lt; \mathrm{cf}
\kappa\)</span>として<span class="math inline">\(\left\langle\:
p_\alpha  \; \middle|\;  \alpha &lt; \gamma
\:\right\rangle\)</span>を<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>の降鎖とする．
この時，<span class="math inline">\(\xi &lt; \mathrm{cf}
\kappa\)</span>かつ<span class="math inline">\(\mathrm{dom}(p) &lt;
\kappa\)</span>であることから，<span class="math inline">\(\sup_{\alpha
&lt; \gamma} \mathrm{dom}(p_\alpha) &lt; \kappa\)</span>. よって<span class="math inline">\(p^* \mathrel{:=} \bigcup_{\alpha &lt; \gamma} p_a
\in \mathop{\mathsf{Add}}(\kappa)\)</span>がこの降鎖の下界となる．</p>
<p><span class="math inline">\(\mathop{\mathsf{Add}}(\kappa,
\gamma)\)</span>の方も同様．</p>
</div>
<p>なぜこのような性質を考えるのかというと，<span class="math inline">\(\kappa\)</span>-閉なposetによる強制法は<span class="math inline">\(\kappa\)</span>以下の基数を保つからです．
より具体的に次が成り立ちます：</p>
<div class="lemma">
<p><span class="math inline">\(\mathbb{P}\)</span>が<span class="math inline">\(\kappa\)</span>-閉の時，<span class="math inline">\(V[G] \models {}^{&lt; \kappa} {V} \subseteq
V\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(\mathbb{1} \Vdash \sigma
\in {}^{&lt;\kappa} {V}\)</span>を満たす<span class="math inline">\(\sigma \in V^{\mathbb{P}}\)</span>を固定し，<span class="math inline">\(D \mathrel{:=} \left\{\: p  \;\middle|\;  p \Vdash
\sigma \in \check{V} \:\right\}\)</span>が<span class="math inline">\(\mathbb{P}\)</span>で稠密となる事を示そう．
そこで<span class="math inline">\(p\)</span>を任意に取る． 補題 <a href="#lem:aux-lem">4</a>より<span class="math inline">\(q \Vdash
\mathrm{dom}(\sigma) = \alpha\)</span>を満たすような<span class="math inline">\(\alpha &lt; \kappa\)</span>と<span class="math inline">\(q \leq p\)</span>が取れる． あとは，<span class="math inline">\(q\)</span>以下の降鎖<span class="math inline">\(\left\langle\: q_\gamma  \; \middle|\;  \gamma
&lt; \alpha \:\right\rangle\)</span>と<span class="math inline">\(\left\langle\: x_\gamma \in V  \;
\middle|\;  \gamma &lt; \alpha \:\right\rangle\)</span>で<span class="math inline">\(q_\gamma \Vdash \sigma(\check{\gamma}) =
\check{x}_\gamma\)</span>を満たすものを，<span class="math inline">\(\kappa\)</span>-閉性を使ってとっていく．
そして最終的に<span class="math inline">\(q^*\)</span>を<span class="math inline">\(q_\alpha\)</span>の下界とすれば，<span class="math inline">\(p \geq q^* \Vdash \text{“}\sigma = \left\langle
\check{x}_\gamma | \gamma &lt; \alpha \right\rangle \in
\check{V}\text{”}\)</span>となるので<span class="math inline">\(q^* \in
D\)</span>が求めるもの．</p>
<p>以上から<span class="math inline">\(V[G] \models {}^{&lt; \kappa} {V}
\subseteq V\)</span>.</p>
</div>
<div class="corollary">
<p><span class="math inline">\(\mathbb{P}\)</span>が<span class="math inline">\(\kappa\)</span>-閉なら<span class="math inline">\(\mathbb{P}\)</span>は<span class="math inline">\(\kappa\)</span>以下の基数を保つ．</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(\mathbb{P}\)</span>での強制によって短い列は増えないので，基数の壊れようがない．</p>
</div>
<div class="lemma">
<p><span class="math inline">\(\kappa\)</span>が正則で<span class="math inline">\(G\)</span>が<span class="math inline">\(V\)</span>上<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>-ジェネリックなら<span class="math inline">\(V[G] \models 2^{&lt; \kappa } =
\kappa\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(2^{&lt; \kappa} \geq
\kappa\)</span>は明らかなので，<span class="math inline">\(\kappa\)</span>から<span class="math inline">\(2^{&lt;\kappa}\)</span>への全射が付け加わる事がわかればよい．
特に，<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>は<span class="math inline">\(\kappa\)</span>-閉なので，<span class="math inline">\(2^{&lt;\kappa}\)</span>は<span class="math inline">\(V\)</span>と<span class="math inline">\(V[G]\)</span>で全く同じである事に注意しよう．
そこで<span class="math inline">\(\left\langle -, - \right\rangle:
\kappa \times \kappa \stackrel{\sim}{\to}
\kappa\)</span>を標準的な全単射で，特に各切片が 次の各集合<span class="math inline">\(D_s\)</span>を考えよう： <span class="math display">\[D_s \mathrel{:=} \left\{\:
p  \;\middle|\;  \exists \alpha &lt; \kappa \: \forall \gamma \in
\mathrm{dom}(s) \:p(\left\langle \alpha, \gamma \right\rangle) = s(i)
\:\right\}\;(s \in {}^{&lt;\kappa} {2}).\]</span> いま適当に<span class="math inline">\(p \in
\mathop{\mathsf{Add}}(\kappa)\)</span>を取れば，<span class="math inline">\(\kappa\)</span>の正則性より<span class="math inline">\(\eta \mathrel{:=} \sup \left\{\:
\alpha+1  \;\middle|\;  \exists \beta \: \left\langle \alpha, \beta
\right\rangle \in \mathrm{dom}(p) \:\right\} &lt;
\kappa\)</span>となる． そこで<span class="math inline">\(p&#39;(\left\langle \eta, \gamma \right\rangle)
\mathrel{:=} s(\gamma)\;(\gamma &lt;
\mathrm{dom}(s))\)</span>として，余りは適当に埋めれば，<span class="math inline">\(p&#39; \leq p\)</span>かつ<span class="math inline">\(p&#39; \in D_s\)</span>を満たす． よって各<span class="math inline">\(D_s\)</span>は<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>で稠密である．</p>
<p>そこで，<span class="math inline">\(V[G]\)</span>で<span class="math inline">\(f \mathrel{:=} \bigcup G\)</span>とおいて，<span class="math inline">\(\mathcal{F} \mathrel{:=} \left\{\:  f(\left\langle
\alpha, - \right\rangle) \upharpoonright \gamma  \;\middle|\;  \gamma,
\alpha &lt; \kappa \:\right\}\)</span>とおけば，<span class="math inline">\(|\mathcal{F}| \leq \kappa\)</span>である．
一方，<span class="math inline">\(s \in {}^{&lt;\kappa}
{2}\)</span>を取れば，<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa)\)</span>の<span class="math inline">\(\kappa\)</span>-閉性より<span class="math inline">\(s \in V\)</span>であり，<span class="math inline">\(G \cap D_s \neq
\emptyset\)</span>を満たすので，定義から<span class="math inline">\(s
\in \mathcal{F}\)</span>となる． よって<span class="math inline">\(2^{&lt;\kappa} \leq |\mathcal{F}| \leq
\kappa\)</span>であるから，<span class="math inline">\(V[G] \models
2^{&lt;\kappa} = \kappa\)</span>が成り立つ．</p>
</div>
<div class="corollary">
<p><span class="math inline">\(G\)</span>: <span class="math inline">\(V\)</span>上<span class="math inline">\(\mathop{\mathsf{Add}}(\kappa^+)\)</span>-ジェネリック
<span class="math inline">\(\implies\)</span> <span class="math inline">\(V[G] \models \text{“}\kappa: \text{基数} \wedge
2^\kappa = \kappa^+\text{”}\)</span>.</p>
<p>特に<span class="math inline">\(\mathop{\mathsf{Add}}(\omega_1)\)</span>は実数を一切足さずに連続体仮説を強制する．</p>
</div>
<div class="proof">
<p><em>Proof.</em> 前の補題より<span class="math inline">\(V[G] \models
2^\kappa = 2^{&lt; \kappa^+} = \kappa^+\)</span>. <span class="math inline">\(\mathop{\mathsf{Add}}(\omega_1)\)</span>は<span class="math inline">\(\omega_1\)</span>-閉なので可算列は増えず，従って実数も足さない．</p>
</div>
<p>このように<span class="math inline">\(\mathrm{CH}\)</span>を強制することも出来ますが，元々は強制法は<span class="math inline">\(\mathrm{CH}\)</span>を破るための発明でした．
それにはどうすればいいでしょうか？
取り敢えず，実数を一つ（対角化すれば可算個）付け加えるのは<span class="math inline">\(\mathop{\mathsf{Add}}(\omega)\)</span>で出来ますから，これを<span class="math inline">\(\aleph_2\)</span>回繰り返してやれば良さそうです．
その際には，上で気にしたように基数を保存するかどうか？というのが重要になってきます．
だって，<span class="math inline">\(\aleph_2\)</span>個実数を足してやったところで，<span class="math inline">\(\aleph_2^V\)</span>が<span class="math inline">\(V[G]\)</span>で可算になっていたら意味がありませんから．
その事を確かめるために閉性とともに良く用いられるのが<span class="sans-serif"><strong><span class="math inline">\(\kappa\)</span>-鎖条件</strong></span>です．</p>
<div class="definition">
<p><span class="math inline">\(\mathbb{P}\)</span>が<span class="sans-serif"><strong><span class="math inline">\(\kappa\)</span>-鎖条件</strong></span>（<span class="sans-serif"><strong><span class="math inline">\(\kappa\)</span>-chain condition</strong></span>,
<span class="sans-serif"><strong><span class="math inline">\(\kappa\)</span>-c.c.</strong></span>）を満たす<span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span> <span class="math inline">\(\mathbb{P}\)</span>の反鎖の濃度は<span class="math inline">\(\kappa\)</span>未満．</p>
</div>
<p>閉性は「小さい」基数を保つ条件でしたが，鎖条件は「大きな」基数を保つ条件です．</p>
<div class="theorem">
<p><a href id="thm:cc-card-pres"></a> <span class="math inline">\(\mathbb{P}\)</span>が<span class="math inline">\(\kappa\)</span>-c.c.を満たすなら<span class="math inline">\(\mathbb{P}\)</span>は<span class="math inline">\(\kappa\)</span>以上の基数を保つ． 即ち<span class="math inline">\(V\)</span>の任意の基数<span class="math inline">\(\lambda \geq \kappa\)</span>について<span class="math inline">\(\mathbb{P} \models \text{“}\check{\lambda}:
\text{基数}\text{”}\)</span>.</p>
</div>
<p>これには次の補題を用いることになります：</p>
<div class="lemma">
<p><a href id="lem:cc-approx-fun"></a> <span class="math inline">\(\mathbb{P}\)</span>が<span class="math inline">\(\kappa\)</span>-c.c.で<span class="math inline">\(\dot{f}\)</span>が<span class="math inline">\(\mathbb{P} \Vdash \dot{f}: \check{A} \to
\check{B}\)</span>を満たす関数の<span class="math inline">\(\mathbb{P}\)</span>-名称なら，<span class="math inline">\(F: A \to [B]^{&lt; \kappa}\)</span>が存在して<span class="math inline">\(\forall x \in \check{A} \:\mathbb{P} \Vdash
\text{“}\dot{f}(\check{x}) \in \check{F}(\check{x})\text{”}\)</span></p>
</div>
<div class="proof">
<p><em>Proof.</em> 以下のように<span class="math inline">\(F\)</span>を定める： <span class="math display">\[F(x) \mathrel{:=} \left\{\: y \in
B  \;\middle|\;  \exists p \in \mathbb{P} \: p \Vdash
\text{“}\dot{f}(\check{x}) = \check{y}\text{”} \:\right\}.\]</span>
すると，<span class="math inline">\(\mathbb{P} \Vdash \dot{f}(\check{x})
\in \check{F}(\check{x})\)</span>は明らか． このままだと<span class="math inline">\(F: A \to
\mathop{\mathcal{P}}(B)\)</span>ということしかわからないので，<span class="math inline">\(|F(x)| &lt; \lambda\)</span>を示そう．
そこで，定義により各<span class="math inline">\(y \in
F(x)\)</span>に対し<span class="math inline">\(p_y \Vdash
\dot{f}(\check{x}) = \check{y}\)</span>を取り，<span class="math inline">\(A_x \mathrel{:=} \left\{\: p_y \in
\mathbb{P}  \;\middle|\;  y \in F(x) \:\right\}\)</span>とおく．
ここで，<span class="math inline">\(p_y \mathrel{\|}
p_z\)</span>とすると，<span class="math inline">\(q \leq p_y,
p_z\)</span>を取れば<span class="math inline">\(q \Vdash
\text{“}\check{y} = \dot{f}(\check{x}) =
\check{z}\text{”}\)</span>となり，定理 <a href="#thm:V-truth-emb-generic">2</a>から<span class="math inline">\(y =
z\)</span>となります． この事から，特に対応<span class="math inline">\(y
\mapsto p_y\)</span>は単射なので<span class="math inline">\(|F(x)| \leq
|A_x|\)</span>となり，更に<span class="math inline">\(A_x\)</span>は反鎖となることがわかります．
すると，<span class="math inline">\(\kappa\)</span>-c.c.から<span class="math inline">\(|F(x)| \leq |A_x| &lt;
\kappa\)</span>を得ます．これが示したかったことでした．</p>
</div>
<div class="proof">
<p><em>Proof of Theorem <a href="#thm:cc-card-pres">8</a>.</em>
基数の極限は基数であり，極限基数は正則基数の極限で書けるので，<span class="math inline">\(\kappa\)</span>以上の正則基数が保たれる事を示せばよい．</p>
<p>そこで，任意の正則基数<span class="math inline">\(\lambda \geq
\kappa\)</span>と<span class="math inline">\(\gamma &lt;
\lambda\)</span>に対し，<span class="math inline">\(\mathbb{P} \Vdash
\dot{f}: \check{\gamma} \to \check{\lambda}\)</span>なら<span class="math inline">\(\mathbb{P} \Vdash \text{“}\dot{f}:
\text{有界}\text{”}\)</span>となる事を示しましょう． この時，上の補題 <a href="#lem:cc-approx-fun">9</a>から<span class="math inline">\(F: \gamma
\to [\lambda]^{&lt;\kappa}\)</span>で任意の<span class="math inline">\(\alpha &lt; \gamma\)</span>に対し<span class="math inline">\(p \Vdash \text{“}\dot{f}(\check{\alpha})\text{”}
\in \check{F}(\check{\alpha})\)</span>を満たす関数が存在します．
今，<span class="math inline">\(\lambda \geq \kappa\)</span>かつ<span class="math inline">\(|F(\alpha)| &lt; \gamma\)</span>であるので，<span class="math inline">\(\lambda\)</span>の正則性より<span class="math inline">\(\xi \mathrel{:=} \sup_{\alpha &lt; \gamma} \sup
F(\alpha) &lt; \lambda\)</span>となります． すると，各<span class="math inline">\(\alpha &lt; \gamma\)</span>について<span class="math inline">\(p \Vdash \dot{f}(\check{\alpha}) \leq \sup
\check{F}(\check{\alpha}) \leq \gamma &lt; \lambda\)</span>.</p>
</div>
<div class="fact">
<p><span class="math inline">\(\mathop{\mathsf{Add}}(\kappa,
\gamma)\)</span>は<span class="math inline">\((2^{&lt;\kappa})^+\)</span>-c.c.を持つ．</p>
</div>
<p>この事実の証明には<span class="math inline">\(\Delta\)</span>-システム補題を使いますが，新しい概念を導入するのが面倒になったのでやりません．
証明じたいはそこまで面倒なものではないので，気になった人はKunen <span class="citation"><a href="#ref-Kunen:2011" role="doc-biblioref"> [4]</a></span>などを参考にしてください．</p>
<div class="corollary">
<p><span class="math inline">\(\mathop{\mathsf{Add}}(\omega,
\gamma)\)</span>は<span class="math inline">\(\omega_1\)</span>-c.c.を持つ． 特に，<span class="math inline">\(\mathop{\mathsf{Add}}(\omega,
\gamma)\)</span>は全ての基数を保存する．</p>
</div>
<div class="lemma">
<p>基数<span class="math inline">\(\lambda\)</span>に対し，<span class="math inline">\(\mathop{\mathsf{Add}}(\omega, \lambda) \Vdash
2^{\aleph_0} \geq \lambda\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> 上の系から<span class="math inline">\(\mathop{\mathsf{Add}}(\omega,
\lambda)\)</span>は全ての基数を保つので，<span class="math inline">\(\lambda\)</span>は依然として基数であることに注意．</p>
<p>そこで<span class="math inline">\(G\)</span>を<span class="math inline">\(V\)</span>上の<span class="math inline">\(\mathop{\mathsf{Add}}(\omega,
\lambda)\)</span>-ジェネリックフィルターとして，以下のように<span class="math inline">\(f_\alpha : \omega \to 2\)</span>を定める： <span class="math display">\[f_\alpha(n) \mathrel{:=} \left(\bigcup
G\right)(\alpha, n)\;(n &lt; \omega, \alpha &lt; \lambda).\]</span>
この時，次の<span class="math inline">\(D_n,
E^\alpha_\beta\)</span>はそれぞれ<span class="math inline">\(\mathop{\mathsf{Add}}(\omega,
\lambda)\)</span>で稠密である： <span class="math display">\[\begin{gathered}
   D_n \mathrel{:=} \left\{\: p \in \mathop{\mathsf{Add}}(\omega,
\lambda)  \;\middle|\;  \forall \alpha \in \mathrm{dom}(p) \: n \in
\mathrm{dom} p(\alpha) \:\right\}\; (n &lt; \omega)\\
  E^\alpha_\beta \mathrel{:=} \left\{\: p \in
\mathop{\mathsf{Add}}(\omega, \lambda)  \;\middle|\;  \exists n \in
\mathrm{dom} p(\alpha) \cap \mathrm{dom} p(\beta) \: p(\alpha)(n) \neq
p(\beta)(n) \:\right\} \; (\alpha &lt; \beta &lt; \lambda).
\end{gathered}\]</span> すると，<span class="math inline">\(D_n \cap G
\neq \emptyset\)</span>より各<span class="math inline">\(f_\alpha :
\omega \to 2\)</span>であり，<span class="math inline">\(E^\alpha_\beta
\cap G \neq \emptyset\)</span>より任意の<span class="math inline">\(\alpha &lt; \beta &lt;
\lambda\)</span>に対して<span class="math inline">\(f_\alpha \neq
f_\beta\)</span>となるから，<span class="math inline">\(\left\{ f_\alpha
\right\}_\alpha\)</span>は<span class="math inline">\(\lambda\)</span>の相異なる実数の列である．
よって<span class="math inline">\(V[G] \models 2^\omega \geq
\check{\lambda}\)</span>.</p>
</div>
<p>よって，<span class="math inline">\(\mathop{\mathsf{Add}}(\omega,
\aleph_2)\)</span>で強制すれば，<span class="math inline">\(\mathrm{CH}\)</span>を破ることが出来た．
実は，適切な仮定の下で<span class="math inline">\(\mathop{\mathsf{Add}}(\omega,
\lambda)\)</span>による強制拡大における連続体の濃度は決定できる．</p>
<div class="lemma">
<p><span class="math inline">\(\mathbb{P}\)</span>が<span class="math inline">\(\lambda\)</span>-c.c.を満たし<span class="math inline">\(|\mathbb{P}| = \nu\)</span>とする． 基数<span class="math inline">\(\mu\)</span>に対して<span class="math inline">\(\theta \mathrel{:=}
(\nu^{&lt;\lambda})^\mu\)</span>とすると<span class="math inline">\(\mathbb{P} \Vdash 2^{\check{\mu}} \leq
\check{\theta}\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> まず，この補題の<span class="math inline">\(\nu^{&lt;\lambda}\)</span>というのは，<span class="math inline">\(\mathbb{P}\)</span>の完備化の濃度の上界である．</p>
<p>鎖条件は稠密埋め込みによって保たれることはすぐにわかる． そこで<span class="math inline">\(\mathbb{P}\)</span>の代わりに完備化<span class="math inline">\(\mathbb{B} =
\mathbb{B}(\mathbb{P})\)</span>を代わりに考えよう． <span class="math inline">\(\mathbb{B}\)</span>は<span class="math inline">\(\mathbb{P}\)</span>の全ての部分集合の上限・下限を付け足して得られる訳だが，「重複」を除いて考えれば，<span class="math inline">\(\mathbb{P}\)</span>の反鎖の上限・下限だけを考えればよい．
いま，<span class="math inline">\(\mathbb{P}\)</span>は<span class="math inline">\(\lambda\)</span>-c.c.を満たすから，反鎖の総数は高々<span class="math inline">\(\nu^{&lt;\lambda}\)</span>個しかない． よって<span class="math inline">\(|\mathbb{B}| \leq
\nu^{&lt;\lambda}\)</span>である．</p>
<p>そこで<span class="math inline">\(\dot{x}\)</span>を<span class="math inline">\(\mathbb{P} \Vdash_{\mathbb{B}} \dot{x} \subseteq
\check{\mu}\)</span>を満たすものとする． このとき， <span class="math display">\[F_{\dot{x}}(\alpha) \mathrel{:=} \left\|
\check{\alpha} \in \dot{x} \right\|_{\,\mathbb{B}}\]</span>
により写像<span class="math inline">\(F_{\dot{x}}: \mu \to
\mathbb{B}\)</span>が定まる． このような写像の総数は<span class="math inline">\(|{}^{\mu} {\mathbb{B}}| = |\mathbb{B}|^\mu \leq
(\nu^{&lt;\lambda})^\mu = \theta\)</span>. <span class="math inline">\(\mathbb{P} \Vdash \text{“}\dot{x} =
\dot{y}\text{”}\)</span>ならば<span class="math inline">\(F_{\dot{x}} =
F_{\dot{y}}\)</span>となるから， よって<span class="math inline">\(\mu\)</span>の部分集合の名称は本質的に<span class="math inline">\(\theta\)</span>個しか存在しないので，<span class="math inline">\(\mathbb{P} \Vdash 2^{\mu} \leq
\check{\theta}\)</span>.</p>
</div>
<div class="corollary">
<p><span class="math inline">\(\mathrm{GCH}\)</span>を仮定する． <span class="math inline">\(\mathrm{cf} \lambda &gt; \omega\)</span>なら<span class="math inline">\(\mathop{\mathsf{Add}}(\omega, \lambda) \Vdash
2^{\omega} = \check{\lambda}\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(|\mathop{\mathsf{Add}}(\omega, \lambda)| =
[\lambda]^{&lt;\omega} \times 2^{&lt;\omega} = \lambda \times \omega =
\lambda\)</span>. そこで，先の補題において<span class="math inline">\(\lambda \mathrel{:=} \omega_1\)</span>, <span class="math inline">\(\nu \mathrel{:=} \lambda\)</span>, <span class="math inline">\(\mu \mathrel{:=} \omega\)</span>とおけば， <span class="math inline">\(\theta = (\lambda^{&lt;\omega_1})^\omega =
\lambda^\omega = \lambda\)</span>（最後の<span class="math inline">\(=\)</span>は<span class="math inline">\(\mathrm{GCH}\)</span>および<span class="math inline">\(\mathrm{cf} \lambda &gt; \omega\)</span>より）．
よって<span class="math inline">\(\mathop{\mathsf{Add}}(\omega, \lambda)
\Vdash 2^\omega = \check{\lambda}.\)</span></p>
</div>
</section>
<section id="hamkinsの自然主義強制法" class="level1">
<h2>Hamkinsの〈自然主義〉強制法</h2>
<p>最後に，Hamkins <span class="citation"><a href="#ref-Hamkins:2012qv" role="doc-biblioref">
[1]</a></span>らの「自然主義的」な強制法の説明について説明しましょう．
そのままでは<span class="math inline">\(V^{\mathbb{B}}\)</span>はBoole値モデルであって普通のモデルではないが，それを<span class="math inline">\(\mathbb{B}\)</span>上の超フィルターで割ることによって通常の（定義可能なクラス）モデルを得よう，という考え方です．</p>
<div class="definition">
<p><span class="math inline">\(\mathcal{U}\)</span>を<span class="math inline">\(\mathbb{B}\)</span>上の超フィルターとする．
この時，<span class="math inline">\(V^{\mathbb{B}}/\mathcal{U}\)</span>,
<span class="math inline">\(\check{V}_{\mathcal{U}}\)</span>および<span class="math inline">\(j_{\mathcal{U}}: V \to
\check{V}_{\mathcal{U}}\)</span>を次で定める： <span class="math display">\[\begin{gathered}
  \dot{x} \sim_{\mathcal{U}} \dot{y} \xLeftrightarrow{\mathrm{def}}
\left\| \dot{x} = \dot{y} \right\|_{\,} \in \mathcal{U}, \qquad{}
  [\dot{x}]_{\mathcal{U}} \mathrel{:=} \left(\left\{\: \dot{y} \in
V^{\mathbb{B}}  \;\middle|\;  \dot{x} \sim_{\mathcal{U}} \dot{y}
\:\right\} \text{の中でランク最小のもの全体}\right)\\{}
  [\dot{x}]_{\mathcal{U}} \mathrel{E} [\dot{y}]_{\mathcal{U}}
\xLeftrightarrow{\mathrm{def}} \left\| \dot{x} \in \dot{y} \right\|_{\,}
\in \mathcal{U},\qquad
  V^{\mathbb{B}} / \mathcal{U} \mathrel{:=} (\left\{\:
[\dot{x}]_{\mathcal{U}}  \;\middle|\;  \dot{x} \in V^{\mathbb{B}}
\:\right\}, \mathrel{E}),\\
  \check{V}_{\mathcal{U}} \mathrel{:=} \left\{\: [\sigma]_{\mathcal{U}}
\in V^{\mathbb{B}}/\mathcal{U}  \;\middle|\;  \left\| \sigma \in
\check{V} \right\|_{\,} \in \mathcal{U} \:\right\},\\
  j_{\mathcal{U}}(x) \mathrel{:=} [\check{x}]_{\mathcal{U}}.
\end{gathered}\]</span></p>
<p><span class="math inline">\(\check{V}_\mathcal{U}\)</span>を<span class="sans-serif"><strong>Boole超冪</strong></span>と呼ぶ．</p>
</div>
<div class="theorem">
<p>任意のcBa <span class="math inline">\(\mathbb{B}\)</span>に対して，定義可能なクラスへの初等埋め込み<span class="math inline">\(j: V \xrightarrow{\prec} \bar{V}\)</span>と<span class="math inline">\(\bar{V}\)</span>上の<span class="math inline">\(\bar{\mathbb{B}} \mathrel{:=}
j(\mathbb{B})\)</span>-ジェネリックフィルター<span class="math inline">\(\bar{G} \in V\)</span>が存在する． <span class="math display">\[V \prec \bar{V} \subseteq
\bar{V}[\bar{G}].\]</span> 特に，<span class="math inline">\(\bar{V}[\bar{G}]\)</span>と<span class="math inline">\(j\)</span>は<span class="math inline">\(V\)</span>で定義可能クラスになっている．</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(\mathcal{U}\)</span>を適当な<span class="math inline">\(\mathbb{B}\)</span>上の超フィルターとして，<span class="math inline">\(\bar{V} \mathrel{:=}
\check{V}_{\mathcal{U}}\)</span>, <span class="math inline">\(j
\mathrel{:=} j_{\mathcal{U}}\)</span>，<span class="math inline">\(\bar{G} \mathrel{:=}
[\dot{G}]_{\mathcal{U}}\)</span>とおけばよい．</p>
</div>
<p>ここで重要なのは，<span class="math inline">\(\mathcal{U}\)</span>は超フィルターなら<span class="sans-serif"><strong>なんでもいい</strong></span>という事です．
これは，<span class="math inline">\(V\)</span>は普通の<span class="math inline">\(\in\)</span>-モデルであるのに対して，<span class="math inline">\(\check{V}_{\mathcal{U}}\)</span>などは一般に整礎とは限らない<span class="math inline">\(E\)</span>を所属関係に持ち，更に<span class="math inline">\(\bar{G} \in V\)</span>は（メタ的に<span class="math inline">\(V\)</span>上と見做せるにしても）<span class="math inline">\(\bar{V}\)</span>上のジェネリックフィルターであって<span class="math inline">\(V\)</span>上のものではないためです．</p>
<p>更に，Łośの定理に相当する，次の定理が成り立ちます：</p>
<div class="theorem">
<p><a href id="thm:los"></a> 超フィルター<span class="math inline">\(\mathcal{U}\)</span>に対し<span class="math inline">\(\left\| \varphi(\tau) \right\|_{\,} \in
\mathcal{U} \iff V^{\mathbb B} / \mathcal{U} \models
\varphi([\tau]_{\mathcal{U}})\)</span>.</p>
</div>
<p>これには，次の定理が必要になります：</p>
<div class="theorem">
<p>論理式<span class="math inline">\(\varphi[x,
\vec{y}]\)</span>に対し，<span class="math inline">\(\dot{x} \in
V^{\mathbb{B}}\)</span>で<span class="math inline">\(\left\| \exists x
\: \varphi[x, \vec{\sigma}] \right\|_{\,} = \left\| \varphi[\dot{x},
\vec{\sigma}] \right\|_{\,}\)</span>を満たすものが存在する．</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(b \mathrel{:=} \left\|
\exists x \: \varphi(\dot{x}) \right\|_{\,}\)</span>とすると，定義から，
<span class="math display">\[b = \sum_{\dot{x} \in V^\mathbb{B}} \left\|
\varphi(\dot{x}) \right\|_{\,}.\]</span> そこで<span class="math inline">\(S \mathrel{:=} \left\{\:  \left\| \varphi(\dot{x})
\right\|_{\,}  \;\middle|\;  \dot{x} \in V^{\mathbb{B}}
\:\right\}\)</span>とおいて，<span class="math inline">\(S\)</span>の元以下の所で極大な反鎖<span class="math inline">\(A \subseteq \mathop{\downarrow} S\)</span>を取る．
この時<span class="math inline">\(\sum A = b\)</span>. そこで，各元<span class="math inline">\(p \in A\)</span>に対して，<span class="math inline">\(p \leq \left\| \varphi(\sigma_p)
\right\|_{\,}\)</span>となるような<span class="math inline">\(\sigma_p\)</span>を固定しておく． すると，<span class="math inline">\(\dot{x} \mathrel{:=} \left\{\: \left\langle \tau,
p \cdot q \right\rangle  \;\middle|\;  p \in A, \left\langle \tau, q
\right\rangle \in \sigma_p \:\right\}\)</span>が求めるものとなる．
定め方より各<span class="math inline">\(p \in A\)</span>に対し<span class="math inline">\(p \leq \left\| \varphi(\dot{x})
\right\|_{\,}\)</span>となるので<span class="math inline">\(b = \sum A
\leq \left\| \varphi(\dot{x}) \right\|_{\,}\)</span>. 一方で<span class="math inline">\(\dot{x} \in
V^{\mathbb{B}}\)</span>なので定義より<span class="math inline">\(\left\|
\varphi(\dot{x}) \right\|_{\,} \in S\)</span>となるので，<span class="math inline">\(\left\| \varphi(\dot{x}) \right\|_{\,} \leq \sum S
= b\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof of Theorem <a href="#thm:los">10</a>.</em>
原子論理式については，定義から明らか．</p>
<p>複合論理式については，論理式の長さに関する帰納法で示す．
Boole結合について： <span class="math display">\[\begin{alignedat}{2}
  \left\| \neg \varphi \right\|_{\,} = - \left\| \varphi \right\|_{\,}
\in \mathcal{U}
  &amp;\iff \left\| \varphi \right\|_{\,} \notin \mathcal{U}
&amp;\qquad&amp; (\because\ \mathcal{U}: \text{フィルタ})\\
  &amp;\iff V^{\mathbb B}/\mathcal{U} \nvDash \varphi &amp;&amp;
(\text{帰納法の仮定})\\
  &amp;\iff V^{\mathbb B}/\mathcal{U} \models \neg \varphi.\\
  \left\| \varphi \wedge \psi \right\|_{\,} = \left\| \varphi
\right\|_{\,} \cdot \left\| \psi \right\|_{\,} \in \mathcal{U}
  &amp;\iff \left\| \varphi \right\|_{\,}, \left\| \psi \right\|_{\,}
\in \mathcal{U} &amp; &amp; (\mathcal{U}: \text{フィルタ}) \\
  &amp;\iff V^{\mathbb{B}}/\mathcal{U} \models \varphi, \psi &amp;&amp;
(\text{帰納法の仮定})\\
  &amp;\iff V^{\mathbb{B}}/\mathcal{U} \models \varphi \wedge \psi
\end{alignedat}\]</span>
最後に量化子について．特に存在量化だけ考えればよい． 極大原理により<span class="math inline">\(\varphi(x)\)</span>に対して<span class="math inline">\(\left\| \varphi(\dot{x}) \right\|_{\,} = \left\|
\exists x \: \varphi(x) \right\|_{\,}\)</span>となる<span class="math inline">\(\dot{x}\)</span>を取れば， <span class="math display">\[\begin{aligned}
  \left\| \exists x \: \varphi(x) \right\|_{\,} = \left\|
\varphi(\dot{x}) \right\|_{\,} \in \mathcal{U}
  \iff V^{\mathbb{B}}/{\mathcal{U}} \models
\varphi([\dot{x}]_{\mathcal{U}}) \implies V^{\mathbb{B}}/\mathcal{U}
\models \exists x \: \varphi(x).
\end{aligned}\]</span> また，<span class="math inline">\(V^{\mathbb{B}}/\mathcal{U} \models \exists x \:
\varphi(x)\)</span>とすると， <span class="math inline">\([\dot{y}] \in
V^{\mathbb{B}}/\mathcal{U}\)</span>があって， <span class="math display">\[\begin{alignedat}{2}
  V^{\mathbb{B}}/\mathcal{U} \models \exists x \: \varphi(x)
  &amp;\implies V^{\mathbb{B}}/\mathcal{U} \models
\varphi([\dot{y}]_{\mathcal{U}})\\
  &amp;\iff \left\| \exists x \: \varphi(x) \right\|_{\,} =
\sum_{\dot{z}} \left\| \varphi(\dot{z}) \right\|_{\,} \geq \left\|
\varphi(\dot{y}) \right\|_{\,} \in \mathcal{U} &amp;\quad&amp;
(\text{帰納法の仮定}).\\
  &amp;\implies \left\| \exists x \: \varphi(x) \right\|_{\,} \in
\mathcal{U} &amp;&amp; (\mathcal{U}: \text{フィルタ}).
\end{alignedat}\]</span> よって<span class="math inline">\(\left\|
\exists x \: \varphi(x) \right\|_{\,} \in \mathcal{U} \iff
V^{\mathbb{B}}/\mathcal{U} \models \exists x \in
\varphi(x)\)</span>.</p>
</div>
<div class="corollary">
<p><span class="math inline">\(V^{\mathbb{B}}/\mathcal{U} \models
\mathrm{ZFC}\)</span>.</p>
</div>
<p>つまり，強制法とは<span class="math inline">\(\left\| \varphi
\right\|_{\,} \in \mathcal{U}\)</span>を満たす超フィルタを見付けて<span class="math inline">\(V^{\mathbb{B}}/\mathcal{U}\)</span>を考えることに外ならなかった訳です．
そして，多くの場合は<span class="math inline">\(\left\| \varphi
\right\|_{\,} =
\mathbb{1}\)</span>なので，これは自明になりたっていた，という事です．</p>
<p>特に，ジェネリックフィルタ<span class="math inline">\(G\)</span>によるBoole超冪である場合は，<span class="math inline">\(\check{V}_G \simeq V\)</span>となります：</p>
<div class="theorem">
<p>必ずしも<span class="math inline">\(V\)</span>に属するとは限らない超フィルタ<span class="math inline">\(U\)</span>について，次は同値：</p>
<ol>
<li><p><a href id="item:U-generic"></a><span class="math inline">\(U\)</span>が<span class="math inline">\(V\)</span>上ジェネリック</p></li>
<li><p><a href id="item:jU-iso"></a><span class="math inline">\(j_U\)</span>は自明で<span class="math inline">\(V\)</span>から<span class="math inline">\(\check{V}_U\)</span>への同型射となる．</p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(\href{\#item:U-generic}{(1)} \implies
\href{\#item:jU-iso}{(2)}\)</span>を示す． <span class="math inline">\([\sigma] \in \check{V}_U\)</span>をとれば，<span class="math inline">\(b \mathrel{:=} \left\| \sigma \in \check{V}
\right\|_{\,} \in U\)</span>である． この時，<span class="math inline">\(A \mathrel{:=} \left\{\:  \left\| \sigma =
\check{x} \right\|_{\,}  \;\middle|\;  x \in V, \left\| \sigma =
\check{x} \right\|_{\,} \neq \mathbb{0} \:\right\} \in V\)</span>は<span class="math inline">\(b\)</span>以下の極大反鎖なので，<span class="math inline">\(U\)</span>のジェネリック性から<span class="math inline">\(U \cap A \neq \emptyset\)</span>.
そこで唯一に決まる<span class="math inline">\(\left\| \sigma = \check{x}
\right\|_{\,} \in U\)</span>が取れ，<span class="math inline">\([\sigma]
= [\check{x}] = j_U(x)\)</span>を得る． したがって<span class="math inline">\(j_U\)</span>は全射であり，初等性から同型となる．</p>
<p>逆に<span class="math inline">\(\href{\#item:jU-iso}{(2)} \implies
\href{\#item:U-generic}{(1)}\)</span>を示す． <span class="math inline">\(j_U\)</span>を同型とする． <span class="math inline">\(A \in V\)</span>を<span class="math inline">\(\mathbb{B}\)</span>の極大反鎖とした時，<span class="math inline">\(a \in A\)</span>に対し<span class="math inline">\(a = \left\| \check{a} = \sigma
\right\|_{\,}\)</span>を満たすような<span class="math inline">\(\mathbb{B}\)</span>-名称<span class="math inline">\(\sigma \in V^{\mathbb{B}}\)</span>が取れる．
このとき<span class="math inline">\(\left\| \tau \in \check{A}
\right\|_{\,} = \mathbb{1}\)</span>となるので，特に<span class="math inline">\(\left\| \tau \in \check{V} \right\|_{\,} =
\mathbb{1}\)</span>となり<span class="math inline">\([\tau] \in
\check{V}_U\)</span>. いま，<span class="math inline">\(j_U\)</span>は同型なので，<span class="math inline">\(\left\| \sigma = \check{x} \right\|_{\,} \in
U\)</span>を満たす<span class="math inline">\(x \in
V\)</span>が存在し，更に<span class="math inline">\(\left\| \sigma \in
\check{a} \right\|_{\,}\)</span>より<span class="math inline">\(x \in
A\)</span>でなくてはならない． すると<span class="math inline">\(x =
\left\| x = \sigma \right\|_{\,} \in U\)</span>となり，<span class="math inline">\(x \in A \cap U \neq \emptyset\)</span>を得，
従って<span class="math inline">\(U\)</span>は<span class="math inline">\(V\)</span>上ジェネリック．</p>
</div>
</section>
<section id="通常の超冪とboole超冪の関係" class="level1">
<h2>通常の超冪とBoole超冪の関係</h2>
<p>以下では，「Boole超冪」<span class="math inline">\(\check{V}_{\mathcal{U}}\)</span>が本当に超冪の一般化となっている事を見ます．
そのために，<span class="math inline">\(\check{V}_{\mathcal{U}}\)</span>の代数的な表示を与えることにしましょう．</p>
<div class="definition">
<ul>
<li><p>極大反鎖<span class="math inline">\(A, B \subseteq
\mathbb{B}\)</span>に対し，<span class="math inline">\(\forall x \in A
\: \exists y \in B \: x \leq y\)</span>が成り立つとき，<span class="math inline">\(A\)</span>は<span class="math inline">\(B\)</span>の<span class="sans-serif"><strong>細分</strong></span>であるといい<span class="math inline">\(A \leq B\)</span>と書く．</p></li>
<li><p>極大反鎖<span class="math inline">\(A, B\)</span>に対し，<span class="math inline">\(A \wedge B \mathrel{:=} \left\{\: a \cdot
b  \;\middle|\;  a \in A, b \in B, a\cdot b &gt; 0
\:\right\}\)</span>は<span class="math inline">\(A \wedge B \leq A,
B\)</span>となる最大の極大反鎖である．</p></li>
<li><p><span class="math inline">\(f: A \to M\)</span>が<span class="sans-serif"><strong>被覆関数</strong></span> <span class="math inline">\(\xLeftrightarrow{\mathrm{def}}\)</span> <span class="math inline">\(A\)</span>は<span class="math inline">\(\mathcal{B}\)</span>の極大反鎖．</p></li>
<li><p><span class="math inline">\(f: A \to M\)</span>を被覆関数，<span class="math inline">\(B \leq A\)</span>を<span class="math inline">\(A\)</span>の細分とする時，<span class="math inline">\(f\)</span>の<span class="math inline">\(B\)</span>への<span class="sans-serif"><strong>簡約</strong></span>(<span class="math inline">\(f \mathbin{\downarrow} B\)</span>)を次で定める：
<span class="math display">\[(f \mathbin{\downarrow} B)(b) \mathrel{:=}
f(a) \quad \text{for the unique } a \in A \text{ with } a \geq
b.\]</span></p></li>
<li><p><span class="math inline">\(M^{\mathop{\downarrow} \mathbb{B}}
\mathrel{:=} \left\{\: f: A \to M  \;\middle|\;  f: \text{被覆関数}
\:\right\}\)</span>．</p></li>
<li><p><span class="math inline">\(f, g \in M^{\mathop{\downarrow}
\mathbb{B}}\)</span>と超フィルタ<span class="math inline">\(\mathcal{U}\)</span>に対し，<span class="math inline">\(f \equiv_\mathcal{U} g\)</span>を次で定める：
<span class="math display">\[f \equiv_{\mathcal{U}} g \iff \sum
\left\{\: c \in A \wedge B  \;\middle|\;  (f \mathbin{\downarrow} (A
\wedge B))(c) = (g \mathbin{\downarrow} (A \wedge B))(c) \:\right\} \in
\mathcal{U}\]</span> <span class="math inline">\(f\)</span>の<span class="math inline">\(\equiv_\mathcal{U}\)</span>に関する同値類を<span class="math inline">\([f]^*_{\mathcal{U}}\)</span>と表す．</p></li>
<li><p><span class="math inline">\(M^{\mathop{\downarrow}
\mathbb{B}}_\mathcal{U} \mathrel{:=} \left\{\:
[f]^*_{\mathcal{U}}  \;\middle|\;  f \in M^{\mathop{\downarrow}
\mathbb{B}} \:\right\}\)</span>を関数的Boole超冪と呼ぶ.</p>
<p>関係記号<span class="math inline">\(R\)</span>の解釈は次で定める：
<span class="math display">\[M^{\mathop{\downarrow}
\mathbb{B}}_\mathcal{U} \models R([f_1], \dots, [f_n])
\xLeftrightarrow{\mathrm{def}} \sum \left\{\: c \in \bigwedge_{1 \leq i
\leq n} \mathrm{dom}(f_i)  \;\middle|\;  M \models R(f_1(c), \dots
f_n(c)) \:\right\} \in \mathcal{U}.\]</span></p></li>
<li><p><span class="math inline">\(x \in M\)</span>に対し，<span class="math inline">\(\hat{x}(\mathbb{1}) = x\)</span>により<span class="math inline">\(\hat{x}: \left\{ \mathbb{1} \right\} \to
M\)</span>を定める． <span class="math inline">\(\hat{x} \in
M^{\mathop{\downarrow} \mathbb B}\)</span>であり，<span class="math inline">\(j(x) = \hat{x}\)</span>は初等埋め込み．</p></li>
</ul>
</div>
<div class="theorem">
<p>次の図式を可換にする同型<span class="math inline">\(\pi\)</span>が存在する：</p>
<div class="center">
<span class="img-fluid"><object class="img-thumbnail media-object" type="image/svg+xml" data="/math/boolean-valued-model-and-forcing/image-1.svg"><img src="/math/boolean-valued-model-and-forcing/image-1.png" alt="Diagram"></object></span>
</div>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(f: A \to M \in
M^{\mathop{\downarrow} \mathbb{B}}\)</span>に対して，<span class="math inline">\(\pi(f) \mathrel{:=} \tau_f \in M^{\mathbb
B}\)</span>を次で定める： <span class="math display">\[\tau_f
\mathrel{:=} \left\{\:  \left\langle \check{x}, a
\right\rangle  \;\middle|\;  a \in A, x \in f(a)  \:\right\}.\]</span>
ここで，<span class="math inline">\(B \leq A\)</span>なら定義より<span class="math inline">\(\left\| \tau_f = \tau_{f \mathbin{\downarrow} B}
\right\|_{\,} = \mathbb{1}\)</span>かつ<span class="math inline">\(a
\leq \left\| \tau_f = \check{f(a)}
\right\|_{\,}\)</span>となることに注意しよう．</p>
<p>まずこの対応が<span class="math inline">\(\sim\)</span>と<span class="math inline">\(\equiv\)</span>を保つことを観よう． そこで，<span class="math inline">\(f : A \to M\)</span>, <span class="math inline">\(g: B \to M\)</span>を任意にとって<span class="math inline">\(C \mathrel{:=} A \wedge B\)</span>かつ<span class="math inline">\(f^* = f \mathbin{\downarrow} C\)</span>, <span class="math inline">\(g^* \mathrel{:=} g \mathbin{\downarrow}
C\)</span>とおく． 今，任意の<span class="math inline">\(c \in
C\)</span>について， <span class="math display">\[\begin{aligned}
  c \cdot \left\| \tau_{f^*} = \tau_{g^*} \right\|_{\,} = c \cdot
\left\| \check{f^*(c)} = \check{g^*(c)} \right\|_{\,} =
  \begin{cases}
   c &amp; (f^*(c) = g^*(c))\\
   0 &amp; (\text{otherwise})
  \end{cases}
\end{aligned}\]</span> したがって， <span class="math display">\[\begin{aligned}
  f \equiv_\mathcal{U} g
  &amp;\iff \left\| \tau_f = \tau_g \right\|_{\,} = \sum \left\{\: c \in
C  \;\middle|\;  (f \mathbin{\downarrow} C)(c) = (g \mathbin{\downarrow}
C)(c) \:\right\} \in \mathcal{U}\\
  &amp;\iff \tau_f \sim_{\mathcal{U}}  \tau_g.
\end{aligned}\]</span> 以上から，写像<span class="math inline">\([f]^*_{\mathcal{U}} \mapsto
[\tau_f]_{\mathcal{U}}\)</span>はwell-definedであり単射となる．
また，各関係記号についても同様の議論から<span class="math inline">\(\check{M}_{\mathcal{U}} \models
R([\tau_f]_{\mathcal{U}}) \iff M^{\mathop{\downarrow}
\mathbb{B}}_\mathcal{U} \models
R([f]^*_{\mathcal{U}})\)</span>が言える．</p>
<p>よって，あとはこの対応が全射であることが言えればよい． そこで，<span class="math inline">\([\tau]_\mathcal{U} \in
\check{M}_\mathcal{U}\)</span>を取ると，<span class="math inline">\(\sim_{\mathcal{U}}\)</span>の定義から<span class="math inline">\(\left\| \tau \in \check{V} \right\|_{\,} =
\mathbb{1}\)</span>であるとしてよい． そこで，<span class="math inline">\(A = \left\{\: \left\| \tau = \check{x}
\right\|_{\,}  \;\middle|\;  x \in M, \left\| \tau = \check{x}
\right\|_{\,} \neq \mathbb{0} \:\right\}\)</span>として，<span class="math inline">\(f(\left\| \tau = \check{x} \right\|_{\,}) =
x\)</span>により定めれば，明らかに<span class="math inline">\([\tau] =
[\tau_{f_\tau}]\)</span>かつ<span class="math inline">\([f_{\tau_f}]^* =
[f]^*\)</span>を満たす． よってこれらは同型であり，更に<span class="math inline">\([\check{x}]\)</span>と<span class="math inline">\([\hat{x}]\)</span>を互いに写し合うので，初等埋め込みも可換．</p>
</div>
<div class="theorem">
<p>通常の<span class="math inline">\(I\)</span>上の超フィルターによる超冪は<span class="math inline">\(\mathop{\mathcal{P}}(I)\)</span>によるBoole超冪と一致する．</p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\(\mathop{\mathcal{P}}(I)\)</span>の場合，<span class="math inline">\(\mathcal{A} \mathrel{:=} \left\{\: \left\{ i
\right\}  \;\middle|\;  i \in I
\:\right\}\)</span>が最小の極大反鎖となる． ここで<span class="math inline">\(\mathcal{A}\)</span>と<span class="math inline">\(I\)</span>は自然に同一視出来，この同一視の下で超冪はBoole超冪と見做せるし，初等埋め込み写像も自然に同一視出来る．</p>
</div>
</section>
<section id="更新履歴" class="level1">
<h2>更新履歴</h2>
<ul>
<li><p>2016/07/11 11:00:00 JST 公開</p></li>
<li><p>2020/06/22 14:30:00 JST
パラメータが真のクラスを渡る上限・下限について追記</p></li>
<li><p>2022/06/11 18:00:00 JST
推移的モデルについて絶対的な概念として誤って「可算である」を挙げていたので削除。</p></li>
</ul>
<p></p>
</section>
<section id="bibliography" class="level1 unnumbered">
<h2 class="unnumbered">参考文献</h2>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-Hamkins:2012qv" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">J.
D. Hamkins and D. E. Seabold, <span>“Well-founded boolean ultrapowers as
large cardinal embeddings,”</span> 26-Jun-2012. [Online]. Available: <a href="https://arxiv.org/abs/1206.6075">https://arxiv.org/abs/1206.6075</a>.</div>
</div>
<div id="ref-Laver:2007sf" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">R.
Laver, <span>“<a href="http://dx.doi.org/10.1016/j.apal.2007.07.002">Certain very large
cardinals are not created in small forcing extensions</a>,”</span>
<em>Annals of Pure and Applied Logic</em>, vol. 149, no. 1, pp. 1–6,
2007.</div>
</div>
<div id="ref-Ishii:2016db" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">石井大海, <span>“絶対性チートシート,”</span>
2016. [Online]. Available: <a href="http://konn-san.com/math/absoluteness-cheatsheet.html">http://konn-san.com/math/absoluteness-cheatsheet.html</a>.</div>
</div>
<div id="ref-Kunen:2011" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">K.
Kunen, <em>Set theory</em>, vol. 34. College Publications, 2011.</div>
</div>
<div id="ref-Shioya:2014fr" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">塩谷真弘,
<span>“数理論理学IA・IB講義資料,”</span> 2014.</div>
</div>
<div id="ref-Kamo:2007" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">加茂静夫, <span>“集合論のブール値模型,”</span>
2007. [Online]. Available: <a href="http://www.mi.s.osakafu-u.ac.jp/~kada/lss07/kamo-booleanvaluedmodel.pdf">http://www.mi.s.osakafu-u.ac.jp/kada/lss07/kamo-booleanvaluedmodel.pdf</a>.</div>
</div>
<div id="ref-Jech:2002" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">T.
Jech, <em>Set theory: The third millennium edition, revised and
expanded</em>, 3rd ed. Springer-Verlag Berlin Heidelberg New York,
2002.</div>
</div>
</div>
</section>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr></hr>
<ol>
<li id="fn1" role="doc-endnote"><p>置換公理図式に現れる論理式に<span class="math inline">\(\check{V}\)</span>を入れてよいかどうか？という疑問が沸くかもしれません．ここでは立ち入りませんが，実は<span class="math inline">\(V^{\mathbb{B}}\)</span>で<span class="math inline">\(V\)</span>を定義出来ることが知られています <span class="citation"><a href="#ref-Laver:2007sf" role="doc-biblioref"> [2]</a></span>．なので，置換公理図式の中に<span class="math inline">\(\check{V}\)</span>が入っていても問題はありません．詳細は拙稿『<a href="https://konn-san.com/math/geology-ground-definability.html">集合論の地質学1：概観と基礎モデルの定義可能性</a>』を参照の事．<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
    </entry>
    <entry>
      <title>Talks</title>
      <link href="https://konn-san.com/talks.html" />
      <id>https://konn-san.com/talks.html</id>
      <published>2022-03-06T14:05:00+09:00</published>
      <updated>2022-03-06T14:05:00+09:00</updated>
      <summary type="html"><![CDATA[<section id="講演一覧" class="level1">
<h2>講演一覧</h2>
<p>他の詳細な経歴等は<a href="/profile.html">プロファイル</a>を参照。</p>
<p><ul>
<li>2023/03/12 
Tsukuba Computer Mathematics Seminar 2023＠Hybrid (Tsukuba and Online)『<b>Reverse-Mode 自動微分を理解する</b>』（<a href="https://konn-san.com/math/reverse-mode-ad-slides.pdf">Slides</a>）</li>
<li>2022/03/06 
Tsukuba Computer Mathematics Seminar 2022＠Hybrid (Tsukuba and Online)『<b>計算代数を駆使して（一般化）フィボナッチ数列の一般項を求める</b>』（<a href="https://konn-san.com/math/ishii-fibonacci-slides.pdf">Slides</a>）</li>
<li>2021/09/15 
<a href="https://www.casc-conference.org/2021/index.html">Computer Algebra in Scientific Computing 2021</a>＠Hybrid (Sochi, Russia and Online)『<b>Automatic differentiation with higher infinitesimals, or computational smooth infinitesimal analysis in Weil algebra</b>』（<a href="https://arxiv.org/abs/2106.14153">Preprint</a>，<a href="https://konn-san.com/math/casc-smooth.pdf">Slides</a>，<a href="https://link.springer.com/book/10.1007/978-3-030-85165-1">Proceedings</a>）</li>
<li>2021/07/04 
<a href="https://www.youtube.com/channel/UCSA2iDIY6Z-J9X4pWfdPPnw">alg-d</a>＠YouTube『<b>自動微分とGröbner基底による高次冪零無限小解析（alg_d篇）</b>』（<a href="https://www.youtube.com/watch?v=0xtOjwQaib4">YouTube</a>，<a href="https://arxiv.org/abs/2106.14153">Paper</a>，<a href="https://konn-san.com/math/smooth-algd-talk.pdf">Slides</a>）</li>
<li>2020/12/22 
<a href="http://www.nda.ac.jp/cc/masayo/20/rims20.html">Computer Algebra – Theory and its Applications</a>＠Zoom Webinar『<b>自動微分と Gröbner 基底による高次冪零無限小解析</b>』</li>
<li>2019/11/09 
<a href="https://techplay.jp/event/727059">Haskell Day 2019</a>＠TECH PLAY SHIBUYA『<b>大規模数値計算を支える Haskell ── Pragmatic Haskell in Large-Scale Numerical Computation──</b>』（<a href="https://speakerdeck.com/konn/da-gui-mo-shu-zhi-ji-suan-wozhi-eru-haskell-nil-nil-pragmatic-haskell-in-large-scale-numerical-computation-nil-nil">Slide URL</a>）</li>
<li>2018/11/24 
数学基礎論若手の会＠コテージにらい恩納『<b>集合論の生成的多元宇宙と地質学入門 生成拡大の織り成すネットワーク</b>』（<a href="https://gitlab.com/konn/wakate-2018/raw/master/slide.pdf">Slide PDF</a>）</li>
<li>2018/09/19 
<a href="http://www.casc.cs.uni-bonn.de/2018/">Computer Algebra in Scientific Computing 2018</a>＠University of Lille『<b><a href="/math/casc2018-talk.pdf">A Purely Functional Computer Algebra System Embedded in Haskell</a></b>』</li>
<li>2018/03/05 
筑波大学計算機数学グループ 春の合宿 2018＠Nami Kaze Tateyama（旧・筑波大学館山研修所）『<b><a href="/math/tateyama-18-satysfi.pdf">SATySFi を使ってみた</a></b>』</li>
<li>2017/11/07 
<a href="http://www2.kobe-u.ac.jp/~brendle/rims2017/e-home.html">Workshop on Iterated Forcing Theory and Cardinal Invariants</a>＠RIMS『<b><a href="/math/rims2017.pdf">Reflection Principles and Saturated Filters on \(\mathcal{P}_{\omega_1} \lambda\)</a></b>』</li>
<li>2017/10/27 
数学基礎論若手の会2017＠大学セミナーハウス『<b>正集合の反映原理と飽和イデアルの構成</b>』（<a href="/math/wakate-2017.pdf">Slide PDF</a>）</li>
<li>2017/03/06 
筑波大学計算機数学グループ 春の合宿 2017＠筑波大学館山研修所『<b>ものまね鳥を愛でる 結合子論理と計算</b>』（<a href="https://www.slideshare.net/konn/ss-72840520">SlideShare</a>，<a href="/math/mocking-bird-tateyama.pdf">PDF</a>）</li>
<li>2016/10/23 
数学基礎論若手の会2016＠清里高原『<b>On Projective Baire Property</b>』（<a href="/math/projective-baire-fmyg16.pdf">Slide</a>）</li>
<li>2016/06/04 
<a href="https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=ZGVmYXVsdGRvbWFpbnxzaGltaWtlbnh8Z3g6MWY5OWFiZDM2NTcyNzljZQ">第4回つくばフレッシュマンセミナー</a>『<b>集合論への招待　〜実数直線の集合論〜</b>』（<a href="/math/freshman-2016-resume.pdf">資料</a>）</li>
<li>2016/03/08 
<a href="http://logic.cs.tsukuba.ac.jp/ppl2016/">第18回プログラミングおよびプログラミング言語ワークショップ PPL 2016</a>『<b>Freer Monads, More Extensible Effects</b>』（<a href="http://www.slideshare.net/konn/freer-monads-more-extensible-effects-59411772">SlideShare</a>，<a href="/prog/freer-ppl16.pdf">PDF</a>，<a href="/prog/freer-ppl16.key">Keynote</a>）</li>
<li>2015/07/27 
修士論文中間発表『<b>実数の集合はどこまで可測になれるか？Solovay-Shelah による Lebesgue 可測性と〈大きな無限〉の関係に関する結果について（公開版）</b>』（<a href="http://www.slideshare.net/konn/ss-50957683">Slide</a>）</li>
<li>2015/03/08 
筑波大学計算機数学グループ 春の合宿2015＠筑波大学館山研修所『<b>（数式の入った）本をつくる</b>』（<a href="https://www.youtube.com/watch?v=a0NcKmVWKq0">録画</a>，<a href="http://www.slideshare.net/konn/ss-45587178">Slide</a>）</li>
<li>2014/11/20 
数学基礎論若手の会2014＠鳥取『<b>Lebesgue 可測性に関する Solovay-Shelah の結果に必要な記述集合論のごく基本的な事項</b>』（<a href="http://www.slideshare.net/konn/lebesgue-solovayshelah">Slide</a>）</li>
<li>2014/03/20 
PFI社内セミナー『<b>技術者が知るべき Gröbner 基底</b>』（<a href="http://www.ustream.tv/recorded/45083535">UStream [前半]</a>，<a href="http://www.ustream.tv/recorded/45083876">UStream [後半]</a>，<a href="http://www.slideshare.net/konn/grbner">Slide</a>）</li>
<li>2014/03/08 
筑波大学計算機数学グループ春の合宿2014＠筑波大学館山研修所『<b>数学プログラムをHaskellで書くべき6の理由</b>』（<a href="https://www.youtube.com/watch?v=S4_7KVNA-Ww">録画</a>，<a href="http://www.slideshare.net/konn/haskell-6-32258528">Slide</a>）</li>
<li>2013/10/12 
第四回選択公理オフ『<b>数理論理学の初歩の初歩の初歩の……</b>』（<a href="/math/acoff-04.html">HTML</a>，<a href="/math/acoff-04.pdf">PDF</a>）</li>
<li>2013/05/04 
<a href="http://partake.in/events/451a51b0-b18e-4e01-bda4-423bf57f4051">Haskell で計算機代数勉強会</a>『<b>わかったつもりになる Gröbner 基底</b>』（<a href="http://www.slideshare.net/konn/groebner-basisanintroductionreduced">Slide</a>）</li>
<li>2012/11/22 
PFI 社内セミナー『<b>Algebraic DP: 動的計画法を書きやすく</b>』（<a href="http://www.ustream.tv/recorded/27196711">Ustream</a>，<a href="http://www.slideshare.net/konn/algebraic-dp">Slide</a>）</li>
<li>2012/04/22 
(祝) Yesod 1.0 勉強会『<b>Yesod で Blog Engine をつくってみた</b>』（<a href="http://www.justin.tv/kiwamu/b/315818516">録画</a>，<a href="http://www.slideshare.net/konn/yesod-12637438">Slide</a>）</li>
<li>2012/04/12 
PFI 社内セミナー『<b>How wonderful to be (statically) typed 〜型が付くってスバラシイ〜</b>』（<a href="http://www.ustream.tv/recorded/21781769">Ustream</a>，<a href="http://www.slideshare.net/konn/how-wonderful-to-be-statically-typed">Slide</a>）</li>
<li>2011/09/22 
PFI 社内セミナー『<b>Alloy Analyzer のこと</b>』（<a href="http://www.ustream.tv/recorded/17430540">Ustream</a>，<a href="http://www.slideshare.net/konn/alloy-analyzer-9379488">Slide</a>）</li>
</ul>
</p>
</section>]]></summary>
    </entry>
    <entry>
      <title>うたにっき20211227</title>
      <link href="https://konn-san.com/logs/20211227.html" />
      <id>https://konn-san.com/logs/20211227.html</id>
      <published>2021-12-27T18:25:37+09:00</published>
      <updated>2021-12-27T18:25:37+09:00</updated>
      <summary type="html"><![CDATA[<p>最近なんとなく Twitter
で即興的に短歌を読むことにハマっているので、去年散発的に詠んだ歌も含めて自動的に
tumblr に集積しておく場所を作りました：</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>一年くらい遡って自動収集したものなので、うんこちんこみたいな不真面目なネタ短歌もあります。
うんこちんこを真面目にやれというお叱りは甘受します。今後も自動収集なので、不真面目な歌が当然に混る。そもそも真面目に短歌を詠む気があるのかという問題もある。</p>
<hr></hr>
<p>そういえばこの日記はうたったうた（songs I
sang）を書いておくものとしてはじまったのであったのでそっちのうたの話もする。
先日久々に友人とカラオケにいったのだけど、かなり喉が衰えていてこれはやばいと思ったので、最近はうまれてはじめてヒトカラに定期的にいくようになった。
週に1回くらい空いた日を見付けて一時間くらい唄う。
最近はコロナの憂さ晴らしにいろいろ演劇や映像作品を観たりすることが増え、また何か演劇なり映像作品なりを創りたい、という欲求が高まっていて、なので歌を唄う前に発声練習もするようになった。
最初はさすがに十年弱のブランクもあり、ヒトカラに慣れていない羞恥心もあったのであんまり長々と出来なかったのだけど、筋少とかたまとか唄いながら、フト、これ外から漏れ聴こえている立場の人間からしたら発声練習もこれらの曲も奇声を上げているという点では変わらんなと思い至り、爾来人目を憚らずにカラオケの個室で発声練習ができるようになった。</p>
<p>あと最近気付いたんだけど、Queen の We are the Champions とか Princes
of the Universe って唄うとめっちゃ元気でますね。
全能感のある曲は精神に良い働きをもたらす。</p>




<p>調子にのって友人とのカラオケで唄ったら、Killer Queen
を唄ってくれとリクエストがあったので、次に備えて今隙を見て練習している。</p>


<p>最初にこれらの曲を聴いたのは親が聴いてたのを横で、という感じなので、歌詞の聞き取りは当時の語彙力に制限されていたため、Killer
Queen の “Let them eat cake, she says just like Marie Antoinette”
の部分を “Application says, ”
だと思っていたりして、直したつもりだが時々そっちに揺り戻されてしまう。
マリー・アントワネットの所は聴き取れてたんだから、「ケーキを食べればいいのよ」の類推が効いてもよさそうな物だが意味を捉えて聴いてなかったということですね。</p>
<p>元気の出る曲でいくと、モンティ・パイソンの映画 “Life of Brian”
の主題歌でいつだったかサッカーでも使われていた “Always Look on the
Bright Side of Life” はやはり名曲だと思う。</p>


<p>Monty Python’s Life of Brian
は「キリストと間違われた男・ブライアン」の一生（キリストはキリストで別にいる）を喜劇として描いたコント映画なんだけど、最後ブライアンが磔にされてもう人生終わりだ〜！っていう時に一緒に磔にされている受刑者全員でこの歌を歌い出すというエンディング。
それで「人生なんてクソの塊さ」「無から来て無に還るんだから、失うものなんて何もないでしょ？」「だから人生の明るい面をみていようよ」「人生はショウなんだ、最後までみんなを笑わせていよう」という歌を唄うんだから、今おもうとかなりパンチの効いたラストだと思う。
人生をショウに喩えるというのは、Queen でいえば The Show Must Go On
なんかもそうだけれど、The Show〜
がフレディの病状も踏まえて書かれたこともあってかなり悲壮感があるのに対して、Always
Look
on〜は「前向きな」ニヒリズムを原動力に底抜けに明るい仕上りになっているのは面白い好対照だと思う。
どちらも大好きな名曲だけれど、Always〜のような感じで人生を明るく愉しく生きたいものである。</p>


<hr></hr>
<p>前書いてから期間が経っているのでその間に作ったものの宣伝をしておこう。
大学時代のサークルの同期・後輩と『游』機関という同人団体を立ち上げ、ボードゲームやマーダーミステリーを創ってます。
マーダーミステリーというのは、TRPGの簡易版みたいなもので、実際に推理小説の登場人物になって演じながら犯人を突き止めたり或いは自分の犯行を隠蔽したりといった感じの体感型ゲームです。</p>
<p>第一作は『踊る天狼館の夜』。</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>ある王国の名門公爵家の令嬢と鉄道王の婚約発表パーティの晩、当の公爵本人が殺されてしまい、一同は事件の真相に迫るが、みなそれぞれに思惑を持っており……という作品です。結構盛り沢山に放り込んだので、総プレイ4時間程度、プレイヤー5人＋GMという仕様です。GMなしでもプレイ可能ですが、基本GMあり推奨。DiscordとUdonarium
が使えればプレイできますのでぜひ。</p>
<p>第二作は『座敷わらしのいる家で』。</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>中学時代に泊まった屋敷が火事になった際、〈座敷わらし〉に助けて貰った少年少女たち。
数年を経て同じ屋敷に泊まりにいくが、屋敷の持ち主の息子である歌川が何者かに昏倒させられ──という作品です。
ざっくりと80年代くらいの晩夏を舞台に、ノスタルジーに浸っていただければと思います。
こちらはお手軽に二時間半・GM不要の4人プレイとなっております。こちらもぜひお求めを。</p>
<p>歳の瀬も迫っているので来年の目標を書いておく。アウトプットの年にします。色々なものを創りたいね。
次のマダミスを創ろうという話もあるし、映像作品を創りたいという思いもある。幾つ叶うかはわからないけど、正夢にしたいですね。</p>
<p>それではまたいつか。</p>]]></summary>
    </entry>
    <entry>
      <title>プロフィール</title>
      <link href="https://konn-san.com/profile.html" />
      <id>https://konn-san.com/profile.html</id>
      <published>2021-06-29T16:20:00+09:00</published>
      <updated>2021-06-29T16:20:00+09:00</updated>
      <summary type="html"><![CDATA[<p><a href="/t/cv.pdf">English CV</a></p>
<section id="自己紹介" class="level1">
<h2>自己紹介</h2>
<p>数学と関数型プログラミングを愛でる博士（理学）。数学（集合論をはじめとした数学基礎論および計算代数）と本格ミステリ、関数型プログラミング。時々パズル。</p>
<section id="専門と趣味について" class="level2">
<h3>専門と趣味について</h3>
<dl>
<dt>好きな作家（順不同）</dt>
<dd>
麻耶雄嵩、円城塔、森川智喜、円居挽、倉知淳。座右の書は麻耶雄嵩『<a href="asin:4062638916">夏と冬の奏鳴曲</a>』と円城塔『<a href="asin:4150310203">Boy’s
Surface</a>』。パズル作家の芦ヶ原伸之さんのエッセイも好き。
</dd>
<dt>数学</dt>
<dd>
専攻は集合論を初めとした数理論理学、計算代数、および関数型プログラミング。
</dd>
<dt>プログラミング</dt>
<dd>
中学の頃くらいからやっている。おおよそ REALbasic → Ruby → Haskell
という遍歴を辿っている。他にも色々な言語をつまみぐいしてみたりしたが、現在は
Haskell 一本に落ち着き、飯を食っている。このサイトも Haskell
で生成・管理しています。
</dd>
</dl>
</section>
<section id="受賞歴資格等" class="level2">
<h3>受賞歴・資格等</h3>
<ul>
<li>2015年度 第十四回茗渓会賞</li>
<li>2013年度 早稲田大学基幹理工学部卒業生総代</li>
<li>2013年度 早稲田大学基幹理工学部長賞最優秀賞（第一回）</li>
</ul>
</section>
<section id="年表" class="level2">
<h3>年表</h3>
<ul>
<li>2019/04〜現在 <a href="https://www.deepflow.co.jp">DeepFlow株式会社</a> 研究開発部</li>
<li>2019/04〜2020/03 統計数理研究所 外来研究員</li>
<li>2019/03 筑波大学大学院 数理物質科学研究科 数学専攻
博士後期課程修了</li>
<li>2017/04〜2019/03 日本学術振興会特別研究員（DC2）</li>
<li>2016/04〜 筑波大学大学院 数理物質科学研究科 数学専攻
博士後期課程</li>
<li>2016/03 筑波大学大学院 数理物質科学研究科 数学専攻
博士前期課程修了</li>
<li>2014/04 Google Summer of Code 2014 採択（Haskell
による効率的なGröbner基底計算とそのための疎行列アルゴリズムの実装）</li>
<li>2014/04 筑波大学大学院 数理物質科学研究科 数学専攻入学</li>
<li>2014/03 同卒業（基幹理工学部総代）</li>
<li>2011/04 早稲田大学基幹理工学部 数学科配属</li>
<li>2010/10〜2014/03 <a href="http://preferred.jp/">株式会社 Preferred
Infrastructure</a> アルバイト</li>
<li>2010/08〜09 <a href="http://preferred.jp/">株式会社 Preferred
Infrastructure</a> インターン生</li>
<li>2010/04 早稲田大学基幹理工学部入学</li>
<li>2010/03 神奈川県立横浜緑ヶ丘高校卒業</li>
<li>1992/01/18 生まれる</li>
</ul>
</section>
</section>
<section id="activity" class="level1">
<h2>Activity</h2>
<p>現在・過去の活動記録など。</p>
<section id="papers" class="level2">
<h3>Papers</h3>
<section id="refereed-papers" class="level3">
<h4>Refereed Papers</h4>
<ul>
<li>Hiromi ISHII, “<em>Automatic Differentiation With Higher
Infinitesimals, or Computational Smooth Infinitesimal Analysis in Weil
Algebra</em>”, In: Computer Algebra in Scientific Computation 2021,
pp. 174-191. DOI: <a href="https://doi.org/10.1007/978-3-030-85165-1_11">10.1007/978-3-030-85165-1_11</a>
(<a href="https://github.com/konn/smooth">Example Repository</a>, <a href="https://arxiv.org/abs/2106.14153">arxiv:2106.14153</a>, <a href="/math/casc-smooth.pdf">Slides</a>).</li>
<li>Hiromi ISHII, “<em><a href="https://hdl.handle.net/2241/00156881">Bidirectional Interplay
between Mathematics and Computer Science: Safety and Extensibility in
Computer Algebra and Haskell</a></em>”, Ph.D. Thesis.</li>
<li>Hiromi ISHII, “<em>A Purely Functional Computer Algebra System
Embedded in Haskell</em>” (<a href="https://arxiv.org/abs/1807.01456">preprint</a>), In: Computer
Algebra in Scientific Computing, pp. 288-303. 20th International
Workshop, CASC 2018, Lille, France, September 17-21, 2018. DOI: <a href="https://doi.org/10.1007/978-3-319-99639-4_20">10.1007/978-3-319-99639-4_20</a>.</li>
<li>Hiromi ISHII, “<em><a href="math/regularity-and-inaccessible.html">Regularity Properties of
Sets of Reals and Inaccessible Cardinals</a></em>”, Master’s
Thesis.</li>
<li>Oleg Kiselyov and Hiromi ISHII, “<a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Freer Monads,
More Extensible effects</a>”. Haskell Symposium 2015.</li>
</ul>
</section>
<section id="non-refereed-papers" class="level3">
<h4>Non-refereed Papers</h4>
<ul>
<li>Hiromi Ishii, “<em><a href="RIMSca2021-rims">A Succinct Multivariate
Lazy Multivariate Tower AD for Weil Algebra Computation</a></em>”,
Computer Algebra – Theory and its Applications, RIMS Kôkyûroku No. 2185
(2021), pp. 104-112. (<a href="RIMSca2021-arxiv">arxiv:2103.11615</a>)</li>
</ul>
</section>
<section id="preprints-only" class="level3">
<h4>Preprints-only</h4>
<ul>
<li>Hiromi ISHII, “<em><a href="https://arxiv.org/abs/2103.11751">Functional Pearl: Witness Me –
Constructive Arguments Must Be Guided with Concrete Witness</a></em>”,
2021.</li>
</ul>
</section>
</section>
<section id="talks" class="level2">
<h3>Talks</h3>
<p>勉強会や社内セミナーなどでの発表記録（直近十件；<a href="/talks.html">全一覧</a>）。</p>
<p><ul>
<li>2023/03/12 
Tsukuba Computer Mathematics Seminar 2023＠Hybrid (Tsukuba and Online)『<b>Reverse-Mode 自動微分を理解する</b>』（<a href="https://konn-san.com/math/reverse-mode-ad-slides.pdf">Slides</a>）</li>
<li>2022/03/06 
Tsukuba Computer Mathematics Seminar 2022＠Hybrid (Tsukuba and Online)『<b>計算代数を駆使して（一般化）フィボナッチ数列の一般項を求める</b>』（<a href="https://konn-san.com/math/ishii-fibonacci-slides.pdf">Slides</a>）</li>
<li>2021/09/15 
<a href="https://www.casc-conference.org/2021/index.html">Computer Algebra in Scientific Computing 2021</a>＠Hybrid (Sochi, Russia and Online)『<b>Automatic differentiation with higher infinitesimals, or computational smooth infinitesimal analysis in Weil algebra</b>』（<a href="https://arxiv.org/abs/2106.14153">Preprint</a>，<a href="https://konn-san.com/math/casc-smooth.pdf">Slides</a>，<a href="https://link.springer.com/book/10.1007/978-3-030-85165-1">Proceedings</a>）</li>
<li>2021/07/04 
<a href="https://www.youtube.com/channel/UCSA2iDIY6Z-J9X4pWfdPPnw">alg-d</a>＠YouTube『<b>自動微分とGröbner基底による高次冪零無限小解析（alg_d篇）</b>』（<a href="https://www.youtube.com/watch?v=0xtOjwQaib4">YouTube</a>，<a href="https://arxiv.org/abs/2106.14153">Paper</a>，<a href="https://konn-san.com/math/smooth-algd-talk.pdf">Slides</a>）</li>
<li>2020/12/22 
<a href="http://www.nda.ac.jp/cc/masayo/20/rims20.html">Computer Algebra – Theory and its Applications</a>＠Zoom Webinar『<b>自動微分と Gröbner 基底による高次冪零無限小解析</b>』</li>
<li>2019/11/09 
<a href="https://techplay.jp/event/727059">Haskell Day 2019</a>＠TECH PLAY SHIBUYA『<b>大規模数値計算を支える Haskell ── Pragmatic Haskell in Large-Scale Numerical Computation──</b>』（<a href="https://speakerdeck.com/konn/da-gui-mo-shu-zhi-ji-suan-wozhi-eru-haskell-nil-nil-pragmatic-haskell-in-large-scale-numerical-computation-nil-nil">Slide URL</a>）</li>
<li>2018/11/24 
数学基礎論若手の会＠コテージにらい恩納『<b>集合論の生成的多元宇宙と地質学入門 生成拡大の織り成すネットワーク</b>』（<a href="https://gitlab.com/konn/wakate-2018/raw/master/slide.pdf">Slide PDF</a>）</li>
<li>2018/09/19 
<a href="http://www.casc.cs.uni-bonn.de/2018/">Computer Algebra in Scientific Computing 2018</a>＠University of Lille『<b><a href="/math/casc2018-talk.pdf">A Purely Functional Computer Algebra System Embedded in Haskell</a></b>』</li>
<li>2018/03/05 
筑波大学計算機数学グループ 春の合宿 2018＠Nami Kaze Tateyama（旧・筑波大学館山研修所）『<b><a href="/math/tateyama-18-satysfi.pdf">SATySFi を使ってみた</a></b>』</li>
<li>2017/11/07 
<a href="http://www2.kobe-u.ac.jp/~brendle/rims2017/e-home.html">Workshop on Iterated Forcing Theory and Cardinal Invariants</a>＠RIMS『<b><a href="/math/rims2017.pdf">Reflection Principles and Saturated Filters on \(\mathcal{P}_{\omega_1} \lambda\)</a></b>』</li>
</ul>
<p>
See <a href="/talks.html">Talks</a> for all talks.
</p>
</p>
</section>
<section id="pre-publication-reviews" class="level2">
<h3>Pre-publication Reviews</h3>
<p>プログラミング関連で幾つか出版前のレビューに協力させて頂きました。</p>
<dl>
<dt><a href="asin:4274068854">すごいHaskell楽しく学ぼう！</a></dt>
<dd>
主に他の言語での経験のある人に向けて、Haskell
を一から入門するための本。普通の本やなんかとは一線を画した、肩肘はらない独特の語り口で
Haskell のキモを学ぶことが出来ます。
</dd>
<dt><a href="asin:4274069117">型システム入門
─プログラミング言語と型の理論─</a></dt>
<dd>
型理論入門書の定番・Types and Programming Language
待望の和訳。豪華監修・執筆陣による非常に読み易い翻訳に仕上がっています。型理論に興味のある方はぜひ。
</dd>
<dt><a href="asin:427406896X">関数プログラミング入門 ─Haskell
で学ぶ技法と原理─</a></dt>
<dd>
こちらは Haskell
を使った関数型プログラミングの入門書。関数型プログラミングを体系的に基礎から勉強していくのに適しています。残念ながら余りレビューに参加出来なかった為、名前は出さないで頂きました。
</dd>
<dt><a href="asin:4873116899">Haskellによる並列・並行プログラミング</a></dt>
<dd>
Haskell
で並列・並行プログラミングを行う上で必要な知識が網羅された一冊です。Haskell
で並列・並行処理を用いたプログラムを書こうと思ったら、まずはこの本は必読書でしょう。低レベルな機能の紹介から始まってそこから抽象度の高いライブラリを設計するところまでを解説しているので、既存のライブラリの裏側を知るのにも役立ちますし、関数型プログラミングの方法論を実感することも出来るでしょう。
</dd>
</dl>
</section>
<section id="other-publications" class="level2">
<h3>Other Publications</h3>
<dl>
<dt><a href="http://tcug.jp/books/2013-12/">Coqによる定理証明</a></dt>
<dd>
Tsukuba Coq Users’ Group による、主に Coq
による定理証明の技法についての同人誌。わたしの担当は第三章で、Haskell
を定理証明系として用いる方法を解説する記事を書きました。<a href="/prog/2013-advent-calendar.html">販促記事はこちら</a>。
</dd>
<dt><a href="http://longgate.co.jp/books/grimoire-vol3.html">プログラミングの魔導書
〜Programmers’ Grimoire〜 Vol.3 “Parallel, Concurrent, and Distributed
Programming”</a></dt>
<dd>
株式会社ロングゲート様の技術書に、合成性の高い並行処理を実現する STM
についての入門記事を寄稿させて頂きました。拙稿に限らず、並行・並列処理に関するあらゆる知識の詰まった一冊となっておりますので、是非。
</dd>
</dl>
</section>
</section>]]></summary>
    </entry>
    <entry>
      <title>ゆめにっき20200526</title>
      <link href="https://konn-san.com/logs/20200526.html" />
      <id>https://konn-san.com/logs/20200526.html</id>
      <published>2020-05-26T23:45:00+09:00</published>
      <updated>2020-05-26T23:45:00+09:00</updated>
      <summary type="html"><![CDATA[<p>最後に書いたのが<a href="./20180614.html">2018年06月14日</a>なので、気付けば実に二年ぶりくらいのにっきであって、その間にはアクロバティックな博士号の取り方をして無事標準年限で修了したり、絶対に就活産業の世話になりたくねえ！と叫んで
Twitter
で就職したり東京に引っ越したりと色々あったのだけど、それを書くのはにっきの役割ではないのでにっきをかく。</p>
<p>二年ぶりににっきをかくきっかけは何かと言えば夢で、それは夜に見る夢であって、時制を正しうするなら夜に見た夢の話である。</p>
<p>夢というのは、なんだか良く見るな、というタイプの夢がある。そのなんだか良く見るな、の夢の中にも二通りあって、人生を通して良く見るな、という夢と、最近なんだか良く見るな、という夢だ。前者の夢の例を挙げると、それは知らない駅になっている品川駅で迷う夢であったり、その知らない品川駅から線路を歩いて渡ると高校に繋がる存在しない路線に乗れる夢であったりする。かつてなんだか良く見るな、だった夢というのもあって、これは空飛ぶ透明なサメが人々を襲って、家や学校の校庭などに現れる夢であったりする。このサメは「最終回」で私に倒されて二度と出て来なくなるのだが、この最終回を見たのは幼稚園の頃に住んで川の字になって眠っていた家だった気がするのだが、しかし記憶にある校庭の景色は引っ越した後の小学校のもので、いまいち判然としない。</p>
<p>閑話休題。今日の話は「最近良く見る夢」の延長であって、それは小学校に入り直す夢なのであった。</p>
<p>この夢は、博士を取って東京に出て来てから結構な頻度で見る。心理的には理解できて、「博士号を取る」という幼い頃に見た夢──これは将来の夢の方の夢で、幼稚園の頃は「バスの車内自動発券器が壊れていないか点検する人」「新聞記者」、小学校の頃は「数学者兼推理作家」、中学校の頃は「数学者兼推理作家兼俳優兼劇作家兼演出家」だった──という、ある種一つの目標を達し、その達し方がちょっと非標準的なものであったため、悔いはなくても何処かやりなおせるとしたら……という潜在意識がどこかにあるためだろう。</p>
<p>たとえば、昨日の──というのはもうすぐ一昨日の──夢では小学校に入学する謎のバスに乗っていて、私は今の年齢のままで、しかも生まれたばかりの弟がいた。今日の──というのはもうすぐ昨日の──夢はその続き、という訳ではなさそうだった。もうすぐ一昨日になるその夢では、入学するのは謎の私立学校で、私は義務教育と高校教育は普通の公立しか通ったことがないから、だからどうしても母校たり得るものではない。対して、もうすぐ昨日の夢の舞台は母校の校庭──かつて夢でサメを倒した、と信じているあの校庭──であったからだ。</p>
<p>その校庭で幼心に還りながら、それでも本当は大人の状態で、なぜか同じ小学校にいる今の職場の同僚と遊んでいる。同僚は身体中にロープを巻いてサッカーゴールに結わえつけて回って遊んでいて、私もそんなことをしているのだが、そんなことをしていると大人に怒られる訳である。この「大人」は、PTAの偉い人と先生が重ね合わさったような状態の人で、そんなことをしてはいけない、と窘められる。いつの間にか同僚はいなくなっていて（出番が終わったので）、どういう風向きか、子供の自己決定権に関する議論になる。その議論が終わって「大人」が校庭の裏門から消えると、何となく「今日は家に帰らずに、この校庭の朝礼台の横で一夜を過ごそう」と決意をする。</p>
<p>服などを抱えてかけ布団にして、そうして、夜になる。</p>
<p>ポケットには au
のガラケーが入っている。黒でスタイリッシュに統一されたフタ付きのもので、たしか中学の時に使っていた機種だ。</p>
<p>そのガラケーにはさわらないで、空を見ている。</p>
<p>空を見ているのは本当は大人になっている自分なので、目はとても悪く、裸眼視力は0.1に満たない。にもかかわらず、空は澄みとおって、銀河の星の一粒一粒までも見通せる。その銀河の星々の織り成す輝きに、僕は目を奪われる。ほとんど見惚れている。</p>
<p>そうして、天体ショウが始まる。中空を埋め尽して七色のオーロラが踊り、それはさながら七つのベールの踊りのように幻惑する。そう思えば空全体の星が左から右、右から左と優しい原色の赤や緑が駆けてゆく。不意に色の乱舞はやんで、今度は夜空の恒星たちそのものが一つの調和を持って変幻自在の色に輝き瞬きつづける。</p>
<p>もし仮に私が神秘主義者であったなら、天啓を得たと大悟してしまうような、宇宙の調和と合一したのだと錯覚してしまうようなそれは絶景だった。</p>
<p>少なくとも、これまでに見てきた中で、これほどまでに鮮明な色彩を伴った夢はこれまでになかった事は確かだろう。普段見る夢は、モノクロームという訳ではないが、色は必要な時にだけ必要な場所にあり、それまでは概念そのものを気にする必要がないような、ほとんど脇役のような存在であることが殆んどだった。これほどまでに鮮かな光を放ち訴え掛けてくるような彩りは、これまでの夢には絶えてなかったと言ってよい。</p>
<p>夢見る私は夢中の私もろともこの天上の大花火の虜となった。と、思うや、一瞬にしてこの天体の奇蹟は、諸処方々から打ち上げられ夜空を埋め尽す本物の花火の群れと転じた。といって荘厳さや調和が失われた訳ではなく、その色の音曲乱舞は目とこころを楽しませて余りある、一種偉大さを湛えたものであった。</p>
<p>しかし、それが花火となったことで夢の私の行動も変わる。そういえば今日は花火大会だったかしらと打ち捨てていた携帯電話を手に取って、時間を確認する。もうこんな時間か、家に帰って家族といっしょに花火を見よう。そう思って私は、かけ布団がわりにしていたズボンを穿き（そんなものを布団にするな！）、靴を履いて、朝礼台の横の砂のベッドから起き上がると、家路を急いだ。</p>
<hr></hr>
<p>夢の話は以上。そういえば、このにっきはうたったうたを書くということでうたにっきと題されていた。今日は
Queen
をうたった。夜には昨日つくってあったハヤシライス（良い肉がお手頃だったので）にフェッチーネを入れてスープパスタに換装して食べた。</p>]]></summary>
    </entry>
    <entry>
      <title>Raspberry Pi + VPS で自宅グローバル IP の変更自動検知をやった話</title>
      <link href="https://konn-san.com/articles/2019-03-09-raspi-vpn-dyndns.html" />
      <id>https://konn-san.com/articles/2019-03-09-raspi-vpn-dyndns.html</id>
      <published>2019-03-10T18:00:00+09:00</published>
      <updated>2019-03-10T18:00:00+09:00</updated>
      <summary type="html"><![CDATA[<section id="発端" class="level1">
<h2>発端</h2>
<p>1月中頃につくばから都内に引っ越したんですが、光インターネットを契約したところ、ルータに
VPN サーバの機能がついていた。 大学の VPN
は博士を修了したら使えなくなってしまうし、出先や海外から自室ネットワークにアクセスできると何かと良いことも多かろう、ということで、さっそく使うことにした。
しかし、一つ問題があって、今契約している回線は固定 IP
ではないので、定期的にグローバル IP が変わってしまう。
ルータの機種によっては、グローバル IP
が変わったら自動通知してくれるものもあるようだが、残念ながら私が貸し出されたルータにその機能はなかった。</p>
<p>そこで、折角なの Raspberry Pi でも買って、一定期間ごとにグローバル IP
をチェックし、変更があったら DNS
を更新するようなシステムを作ることにした。</p>
<p>以下、その手順を書いていくが、普通の Debian 同然なのであんまり RasPi
特有のことがなく、どちらかというと BIND9
の設定の仕方とかが本質的に効いている。</p>
<section id="素材" class="level2">
<h3>素材</h3>
<p>こちらが今回買った Raspberry Pi Model B+ です：</p>
<p><a href="asin:B07FQ9678G"><img class="img-fluid img-thumbnail rounded mx-auto d-block" src="./imgs/raspi-vpn-dyndns/raspi-box.jpeg"></a></p>
  <div class="embed w-100 my-4 justify-content-center row py-0">
    

  </div>

<p>ケースや電源ケーブル、microSD、ヒートシンクなどもついて1万弱。
こういうのをやるのは初めてだったので、最初金色と銅色の正方形の板が何なのかよくわからなかったが、これがヒートシンクで、チップの両面に貼り付けると良い感じに熱を逃がしてくれるやつだった。
どうせ記事を書くんだから写真撮ればよかったが撮らなかった。まあ付属品に金色と銅色の正方形の板は1枚ずつしか入っていないのでわかるだろう。</p>
</section>
</section>
<section id="手順" class="level1">
<h2>手順</h2>
<section id="構成の概略" class="level2">
<h3>構成の概略</h3>
<ul>
<li>さくらドメインで取った独自ドメインのサブドメインでVPNにアクセスしたい</li>
<li>通常のサブドメインはさくらのドメイン管理コンパネでよろしくやっている</li>
<li>独自ドメインはさくら VPS にマップしてあり、今回はこの VPS 上で更に
BIND を動かす。</li>
</ul>
<p>以下、例としては <code>example.com</code>
が独自ドメインだと仮定し、以下のような構成にする：</p>
<ul>
<li><code>example.com</code> 全体：さくらのネームサーバで管理</li>
<li><code>home.example.com</code> ゾーン：さくらVPS上に建てた BIND9
で管理
<ul>
<li><code>dns.home.example.com</code>：さくら VP<em>S</em>上の BIND9
へのアドレス</li>
<li><code>vpn.home.example.com</code>：自宅 VP<em>N</em>
へのアクセスポイント</li>
</ul></li>
</ul>
<p>また、IPのプレースホルダとして以下を用いる：</p>
<dl>
<dt><code>1.2.3.4</code></dt>
<dd>
初期状態（現在）の自宅のグローバルIP。<code>curl inet-ip.info</code> や
<code>hostname -i</code> などで調べられる。
</dd>
<dt><code>999.999.999.999</code></dt>
<dd>
さくらVPSの固定グローバルIP。
</dd>
</dl>
</section>
<section id="raspberry-pi-の初期設定" class="level2">
<h3>Raspberry Pi の初期設定</h3>
<p>セットアップには、まず microSD に OS をインストールする必要がある。
実機だけでインストールを行うには外付けの USB
キーボードとマウスが必要なようで少し焦ったが、ふだんラップトップに
Bluetooth で繋いでいる Magic Keyboard と Magic Trackpad 2 を USB
ケーブルで繋いだら普通に使えたので良かった。</p>
  <div class="embed w-100 my-4 justify-content-center row py-0">
    

    

  </div>

<p>説明書に従い、キーボード、マウス（今回はトラックパッド）、外付けディスプレイを繋ぐ。
電源ケーブルを刺すと勝手に起動し、OSのインストール画面に移る。
途中で必要なファイルをダウンロードするので、ここで Wi-Fi の設定なり LAN
ケーブルを繋ぐなりしておく。
最初は何かダウンロード出来ずに失敗していたが、再起動してもっかいやったらうまくいった。何だったんだろう。</p>
<p>後で知ったのだが、PiBakery とかいうのを使うと、ブート用の microSD
にカスタマイズした Raspbian などをインストールできるようだ。</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>てか今みたらホスト名の設定とかも出来るっぽいし、これをちゃんと使えば後の設定の手順も結構省けたかもしれない。
不覚。</p>
<section id="アカウント名パスワードホスト名sshの設定" class="level3">
<h4>アカウント名、パスワード、ホスト名、SSHの設定</h4>
<p>セキュリティホールになるので、アカウント名やホスト名を初期から変更する。
以下では <code>admin</code>
という（ザルな）名前にデフォルトアカウント名が変更されているものとする。
この辺、完全にただの Debian
なので、この辺りを参照してよしなにすれば良い：</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>SSH の設定はまあ、適当にいつものように
<code>/etc/ssh/sshd_config</code> をいじってやれば良い。 まじで Debian
なので、RasPi 特有の書いておくべきことがほとんどないね。</p>
</section>
<section id="ファイアウォール" class="level3">
<h4>ファイアウォール</h4>
<p>念のため、ローカルのネットワークからしかアクセスを受け入れなくする。
ローカルIPの範囲が <code>192.168.0.0/24</code>
のときは以下のようにすれば良い：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo apt-get install ufw            <span class="co"># iptables とか知らないので簡単な ufw を使う</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo ufw default DENY               <span class="co"># デフォルトではあらゆる接続を拒否する</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo ufw allow from 192.168.0.0/24  <span class="co"># 同一ネットワーク内からの接続のみ許可</span></span></code></pre></div>
</section>
</section>
<section id="サーバ側の設定" class="level2">
<h3>サーバ側の設定</h3>
<p>まずさくら VPS 上に BIND をインストールする。
さくらVPSの構成は以下の通り：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /etc/os-release</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="va">NAME</span><span class="op">=</span><span class="st">&quot;Ubuntu&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="va">VERSION</span><span class="op">=</span><span class="st">&quot;16.04.4 LTS (Xenial Xerus)&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="va">ID</span><span class="op">=</span>ubuntu</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="va">ID_LIKE</span><span class="op">=</span>debian</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="va">PRETTY_NAME</span><span class="op">=</span><span class="st">&quot;Ubuntu 16.04.4 LTS&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="va">VERSION_ID</span><span class="op">=</span><span class="st">&quot;16.04&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="va">HOME_URL</span><span class="op">=</span><span class="st">&quot;http://www.ubuntu.com/&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="va">SUPPORT_URL</span><span class="op">=</span><span class="st">&quot;http://help.ubuntu.com/&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="va">BUG_REPORT_URL</span><span class="op">=</span><span class="st">&quot;http://bugs.launchpad.net/ubuntu/&quot;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="va">VERSION_CODENAME</span><span class="op">=</span>xenial</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="va">UBUNTU_CODENAME</span><span class="op">=</span>xenial</span></code></pre></div>
<p>まず BIND9 をインストールする <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo apt-get install <span class="at">-y</span> bind9</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo systemctl stop bind9</span></code></pre></div>
<p>設定をこれから弄るので、一旦止めておく。
どうせ何も設定していないし、どうもゾーンファイルを弄るときには止めておいたほうがいいらしい。</p>
<p>BINDの設定ファイルは <code>/etc/bind/named.conf</code>
だが、デフォルトでは以下のような内容になっている：</p>
<pre class="/etc/bind/named.conf"><code>// This is the primary configuration file for the BIND DNS server named.
//
// Please read /usr/share/doc/bind9/README.Debian.gz for information on the
// structure of BIND configuration files in Debian, *BEFORE* you customize
// this configuration file.
//
// If you are just adding zones, please do that in /etc/bind/named.conf.local

include &quot;/etc/bind/named.conf.options&quot;;
include &quot;/etc/bind/named.conf.local&quot;;
include &quot;/etc/bind/named.conf.default-zones&quot;;</code></pre>
<p>早い話が、BINDのオプションについては
<code>/etc/bind/named.conf.options</code> に、自前のゾーン設定については
<code>named.conf.local</code> に記述するということである。</p>
<section id="更新鍵の生成" class="level3">
<h4>更新鍵の生成</h4>
<p>次に、Dynamic DNS で更新の際に使う鍵一式を生成する。
日本語で読めるリソースだと、秘密鍵を生成する方法の記事ばかりがヒットする。
しかし、 <code>nsupdate</code> のクエリが TLS
などの暗号化を用いているセキュアなものなのか、調べた限り良くわからなかったので、大事を取って公開鍵方式の鍵を使うことを考える。</p>
<p>まず、次のようにして鍵を生成する（<code>vpn.home.example.com</code>
の部分は自分の独自ドメインになる）：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> pwd</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> dnssec-keygen <span class="at">-T</span> KEY <span class="at">-a</span> RSASHA256 <span class="at">-b</span> 2048 <span class="at">-n</span> HOST vpn.home.example.com</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Generating</span> key pair.................................................................</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ex">....................................+++</span> ............................................</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ex">....................................................................................</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ex">...................+++</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Kvpn.home.example.com.+008+12345</span></span></code></pre></div>
<p>するとワーキングディレクトリに
<code>Kvpn.home.example.com.+008+12345.key</code> および
<code>Kvpn.home.example.com.+008+12345.private</code>
という鍵対が生成される。
<code>+</code>以下は生成する度にちがうようで、最後の<code>12345</code>の部分がどうも
ID 扱いになるらしい。 この二つのファイルは、<code>nsupdate</code>
で呼び出す時に必要になるので捨ててはいけないし、バレたら更新出来るようになってしまうので、絶対に秘匿する必要がある。</p>
<p>次に、ゾーンの設定をする。次の内容を
<code>/etc/bind/named.conf.local</code> に追記する：</p>
<pre class="conf"><code>zone &quot;home.example.com&quot; {
     type master;
     file &quot;home.example.com.zone&quot;;
     update-policy {
       grant vpn.home.example.com. name vpn.home.example.com. A;
     };
};</code></pre>
<p>これで、「ゾーンの具体的な設定は
<code>/var/cache/bind/home.example.com.zone</code>を参照」「<code>vpn.home.example.com</code>
を動的に書き換えられるのは、上の <code>.zone</code>
ファイルで指定された鍵を持っている人のみ」という意味になる。</p>
<p>今度は <code>/var/cache/bind/home.example.com.zone</code>
を弄ることになるが、鍵の設定はこのゾーンファイルに書くことになるので、先程生成した公開鍵の内容をメモっておく：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat Kvpn.home.example.com.+008+12345.key</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">vpn.home.example.com.</span> IN KEY 512 3 8 ABCDEFGHIJKLMNOPQRSTUVWXZ...=</span></code></pre></div>
<p>これを踏まえて、home.example.com のゾーンの設定をしていく。
ここでは、VPN
サブドメインの設定、VPN設定の更新鍵の設定と自前BINDへのアドレスの設定を行う。</p>
<pre class="/var/cache/bind/home.example.com.zone"><code>$TTL 86400      ; デフォルトの生存期間（1日）
home.example.com    IN SOA  dns.home.example.com. root.home.example.com. (
          2019031009 ; シリアル番号、日付＋二桁のユニークIDにする。
          3600       ; 更新間隔 (秒、ここでは 1 時間)
          900        ; リトライ間隔 in 秒 (15 minutes)
          604800     ; 有効期限 (1 week)
          3600       ; 最小の生存期間 (1 hour)
          )
          NS      dns.home.example.com.   ; VPS で動かす BIND へのドメイン
$ORIGIN home.example.com.

; vpn.home.example.com に紐づけられた鍵
vpn       KEY     512 3 8 (ABCEDFGHIJKLMNOPQRSTUVWXYZ=...
                          ...=
                          ) ; key id = 12345
$TTL 3600       ; 1 hour
vpn       A       1.2.3.4   ; 初期状態の自宅グローバルIP

$TTL 86400      ; 1 day
dns       A       999.999.999.999   ; さくらVPSの固定IP</code></pre>
<p>上の <code>root.home.example.com</code>
はメールアドレスを表現するらしく、この場合一つ目の <code>.</code>
を置き換えて <code>root@home.example.com</code>
が連絡先メールアドレスとして登録されることになる（らしい）。 上の
<code>.key</code> ファイルの <code>IN</code> 以後の3つの数字が、ここでの
<code>vpn</code> KEY 以後の括弧前の <code>512 3 8</code>
に相当するので、写しておく。
括弧内は、最後にスペース区切りで書かれているハッシュ値をうつす。</p>
<p>括弧内では改行等が効くらしく、<code>ABCDEFGHIJKLMNOPQRSTUVWXZ...=</code>部分はスペースごとに改行・インデントすると読みやすい。
<code>;</code> 以後はコメントになる。</p>
</section>
<section id="さくらドメインネームサーバの設定" class="level3">
<h4>さくらドメインネームサーバの設定</h4>
<p>さくらの会員メニューにログインする：</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>「契約サービスの確認」＞「ドメインの確認」と飛んで、ページ最下部の「ドメインメニュー」をクリック。
「ネームサーバとゾーンの管理」から、今回設定したいドメインの欄の「ゾーン編集」を選び、「変更」に飛ぶ。</p>
<p>まず、DNSサーバへのサブドメインを設定する。
以下のように入力し、「新規登録」をクリックする。</p>
<p><img class="img-fluid img-thumbnail rounded mx-auto d-block" src="./imgs/raspi-vpn-dyndns/dns-setting.png"></p>
<p>ここで続けて <code>home</code>
サブドメインを設定しようとすると上手くいかないことがあるので、一旦「データ送信」を選ぶ。
今度は今設定した DNS サーバに <code>home.example.com</code>
以下を委譲する設定を以下のようにし、「新規登録」→「データ送信」をする。</p>
<p><img class="img-fluid img-thumbnail rounded mx-auto d-block" src="./imgs/raspi-vpn-dyndns/home-setting.png"></p>
</section>
<section id="ファイヤウォールまわりの設定" class="level3">
<h4>ファイヤウォールまわりの設定</h4>
<p>VPS
で特にファイヤウォールを動かしていないなら、上の設定だけで問題ない。
しかし、常識的に考えて VPS も UFW
によるファイヤウォールで守られている筈なので、このままだとDNSサーバにアクセスできない。
そこで、まず53番ポートを開けておく：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo ufw allow 53</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ex">ルールを追加しました</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ex">ルールを追加しました</span> <span class="op">(v6)</span></span></code></pre></div>
<p>この作業を怠っていたので、1時間くらい「設定合ってる筈なのに何も動かない……」となって泣いた。
また、BIND9はデフォルトでランダムなポートにフォールバックするようになっているらしく、このままだとまだ動かないので、BINDを53番ポート固定にしておく必要がある。
以下のように、<code>/etc/bind/named.conf.options</code> の
<code>options{ }</code> 節の末尾に 53
番ポートに固定する設定を加える：</p>
<pre class="/etc/bind/named.conf.options"><code>options {
  ...
  query-source address * port 53;
}</code></pre>
</section>
<section id="bind9-起動" class="level3">
<h4>BIND9 起動</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo systemctl start bind9</span></code></pre></div>
<p>これで多分 VPS 上の DNS は無事動き始める筈である。
設定が上手くいっていることを確かめるため、<code>nsupdate</code> を VPS
上で呼んでみよう。
先程キーを生成したディレクトリに行って、以下を実行してみる。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[vps]</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nsupdate <span class="at">-k</span> Kvpn.home.example.com.+008+12345.private <span class="op">&lt;&lt;EOF</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="st">server 999.999.999.999</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="st">update add vpn.home.example.com. 3600 IN A 1.2.3.4</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="st">send</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="st">quit</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">EOF</span></span></code></pre></div>
<p>特に何も言われなければ成功。<code>3600</code>
の部分はキャッシュが何秒残るかを表している。</p>
<p>DNS設定が浸透するまでにちょっと時間がかかるので、外部からのアクセスが出来るようになるには、少し待つ必要があるかもしれない。</p>
</section>
</section>
<section id="グローバル-ip-自動更新スクリプト" class="level2">
<h3>グローバル IP 自動更新スクリプト</h3>
<p>RasPi 上に戻る。 VPS上から適宜生成したキーペアをコピーしてくる。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[raspi]</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> mkdir ~/.keys</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> scp vps:/path/to/keys/Kvpn.home.example.com.+008+12345.key     ~/.keys</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Kvpn.home.example.com.+008+12345.key</span>      100%   16     1.5KB/s   00:00</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> scp vps:/path/to/keys/Kvpn.home.example.com.+008+12345.private ~/.keys</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Kvpn.home.example.com.+008+12345.private</span>  100%   16     1.5KB/s   00:00</span></code></pre></div>
<p>これを使えば <code>nsupdate</code>
でDNS情報を更新出来る筈なので、さっき実行したのをもっかい実行してみる。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[raspi]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nsupdate <span class="at">-k</span> ~/.keys/Kvpn.home.example.com.+008+12345.private <span class="op">&lt;&lt;EOF</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="st">server 999.999.999.999</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="st">update add vpn.home.example.com. 3600 IN A 1.2.3.4</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="st">send</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="st">quit</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="op">EOF</span></span></code></pre></div>
<p>怒られなければ成功。 あとは更新スクリプト <code>update-ip.sh</code>
を適当に書き、パスの通った場所に置く。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env bash</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="va">IP_FILE</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${HOME}</span><span class="st">/.batch/global_ipaddr&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="va">OLD_IP</span><span class="op">=</span><span class="st">&quot;&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="va">IP</span><span class="op">=</span><span class="kw">`</span><span class="ex">curl</span> inet-ip.info <span class="dv">2</span><span class="op">&gt;</span>/dev/null<span class="kw">`</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;</span><span class="va">$IP_FILE</span><span class="st">&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">OLD_IP</span><span class="op">=</span><span class="va">$(</span><span class="fu">cat</span> <span class="st">&quot;</span><span class="va">${IP_FILE}</span><span class="st">&quot;</span><span class="va">)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="va">${IP}</span><span class="st">&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">[</span> <span class="st">&quot;</span><span class="va">${OLD_IP}</span><span class="st">&quot;</span> <span class="ot">!=</span> <span class="st">&quot;</span><span class="va">${IP}</span><span class="st">&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">echo</span> <span class="st">&quot;IP changed to </span><span class="va">${IP}</span><span class="st">, from the old </span><span class="va">${OLD_IP}</span><span class="st">&quot;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">echo</span> <span class="st">&quot;UPDATING DynDNS...&quot;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="ex">nsupdate</span> <span class="at">-k</span> <span class="va">$HOME</span>/.keys/Kvpn.home.example.com.+008+12345.private <span class="op">&lt;&lt;EOF</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="st">        server dns.home.example.com</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="st">        update add vpn.home.example.com. 3600 IN A </span><span class="va">${IP}</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="st">        send</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="st">        quit</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="op">EOF</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">echo</span> <span class="st">&quot;Updated.&quot;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${IP}</span><span class="st">&quot;</span> <span class="op">&gt;</span> <span class="st">&quot;</span><span class="va">${IP_FILE}</span><span class="st">&quot;</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">echo</span> <span class="st">&quot;IP </span><span class="va">${OLD_IP}</span><span class="st"> remains the same: </span><span class="va">${IP}</span><span class="st">&quot;</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">fi</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
<p>古い情報は <code>$HOME/.batch/global_ipaddr</code>
に保存することにして、適宜 <code class="sourceCode zsh"><span class="fu">mkdir</span> <span class="va">$HOME</span>/.batch</code>
などしておく。 実行権限を付与し、ちゃんと動くことを確認しておく。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> chmod +x update-ip.sh</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> update-ip.sh</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ex">IP</span> changed to 1.2.3.4, from the old</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ex">UPDATING</span> DynDNS...</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ex">Updated.</span></span></code></pre></div>
<p>あとはこれを定期実行すればよい。 cron
は人間が触るものではないので、ここでは systemd を使うことにする。
以下のファイルを作成する：</p>
<p><code>/etc/systemd/system/update-ip.service</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">Unit</span><span class="kw">]</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Description</span><span class="op">=</span><span class="er">Updates</span> <span class="er">global</span> <span class="er">IP</span> <span class="er">address</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">Service</span><span class="kw">]</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Type</span><span class="op">=</span><span class="er">oneshot</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="dt">ExecStart</span><span class="op">=</span><span class="er">/home/admin/bin/update-ip.sh</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="dt">WorkingDirectory</span><span class="op">=</span><span class="er">/home/admin</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="dt">User</span><span class="op">=</span><span class="er">admin</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Restart</span><span class="op">=</span><span class="er">no</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">Install</span><span class="kw">]</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="dt">WantedBy</span><span class="op">=</span><span class="er">multi-user.target</span></span></code></pre></div>
<p><code>/etc/systemd/system/update-ip.timer</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">Unit</span><span class="kw">]</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Description</span><span class="op">=</span><span class="er">Periodically</span> <span class="er">renews</span> <span class="er">global</span> <span class="er">IP</span> <span class="er">address</span> <span class="er">info</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">Timer</span><span class="kw">]</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="dt">OnBootSec</span><span class="op">=</span><span class="dv">1</span><span class="er">min</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="dt">OnUnitActiveSec</span><span class="op">=</span><span class="dv">15</span><span class="er">min</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Unit</span><span class="op">=</span><span class="er">update-ip.service</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">Install</span><span class="kw">]</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="dt">WantedBy</span><span class="op">=</span><span class="er">timers.target</span></span></code></pre></div>
<p>ここでは、起動1分後から、以後15分刻みで定期実行されるようにしてある。
あとはこれらを有効化すれば良い。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo systemctl enable update-ip.service</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo systemctl enable update-ip.timer</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo systemctl start  update-ip.timer</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span></code></pre></div>
<p>以上で、あとは放っておけば遅くとも15分おきに情報が更新され、何も考えずに
<code>vpn.home.example.com</code> から自宅 VPN
に繋げられる筈である。</p>
</section>
</section>
<section id="最後に" class="level1">
<h2>最後に</h2>
<p>そうは言っても、15分のラグが出うるので、ひみつの場所からグローバル IP
の情報にアクセス出来るようにすると良い。 私は適当に Let’s Encrypt
で証明書を取って、TLS + Basic 認証で秘匿された場所に IP
の情報をアップするようにしている。
この辺りのことを書いてもよかったが、あとは完全に個人が何のツールを使っているかに依存するので、詳しくは書かない。
あ、あとここで指定したサブドメイン等は私の本番環境での設定と一致しているとは限りませんので悪しからず。攻撃はやめてね！</p>
<p>書いてみてタイトルにするほど RasPi
特有のこととかがなかったので、ゆくゆくはアイオーティーでディープラーニング（）などをやっていきたい。
ここ改善したら？みたいのがあったら教えてください。ではでは。</p>
</section>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr></hr>
<ol>
<li id="fn1" role="doc-endnote"><p>安全を期するなら、コンテナの中でやった方がいいかも<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
    </entry>
    <entry>
      <title>CaTeX（軽鳥／怪鳥）で快適 LaTeX ライフ in VSCode</title>
      <link href="https://konn-san.com/articles/2018-11-26-happy-latex-with-catex.html" />
      <id>https://konn-san.com/articles/2018-11-26-happy-latex-with-catex.html</id>
      <published>2018-11-26T23:10:00+09:00</published>
      <updated>2018-11-26T23:10:00+09:00</updated>
      <summary type="html"><![CDATA[<section id="catex-のご紹介" class="level1">
<h2>CaTeX のご紹介</h2>
<p>Visual Studio Code に乗り換えたというのは<a href="../prog/migrating-emacs-to-vscode.html">前の記事</a>でも書きましたが、その際には
LaTeX を編集するのに <a href="http://yatex.org">YaTeX</a>
の代替がないのが不満、という話をしていました。</p>
<p>そこで、僕がVSCodeに足りないと思っている <a href="http://yatex.org">YaTeX</a> 機能を実現する機能拡張 <a href="https://marketplace.visualstudio.com/items?itemName=mr-konn.catex">CaTeX</a>
をリリースしました！</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>有り難いことに、<a href="http://yatex.org/#catex">YaTeX
公式でもご紹介</a>頂いています。</p>
<p>先日の研究集会のスライドは CaTeX で書き進めて、今は一段落しています。
とはいえ、これからD論を書くので、まだドッグフーディングは続いていくと思います。
というわけで、今回は、CaTeXのアレコレについて説明させて頂こうかなと思います。</p>
<section id="名称" class="level2">
<h3>名称</h3>
<p>YaTeX ファミリーは <span class="math inline">\(\TeX\)</span>
が日本語で「てふ」と呼ばれがちなことを逆手にとって、和名として「○○てふ」→「○○鳥」を名乗ることが多いです。
今回は Visual Studio Code の Code から<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> C
を採って <em>CaTeX</em>
と命名し、ローマ字というより英語的に発音して「けいてふ→けいちょう→軽鳥」、あるいは約めて「けてふ→けちょう→怪鳥」と読むことにしました。</p>
</section>
<section id="設計思想と機能" class="level2">
<h3>設計思想と機能</h3>
<p><a href="https://marketplace.visualstudio.com/items?itemName=mr-konn.catex">Marketplace</a>でも紹介していますが、CaTeX
は主に James Yu 氏の <strong><a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop">LaTeX
Workshop</a> と共に使うことを想定</strong>しています。</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>LaTeX Workshop は本当に良く出来た拡張で、SyncTeX の機能（PDF と TeX
本文の往き来）や参考文献ブラウザ、自動タイプセットなど本当に豊富な機能があります。
スニペットを使ったコマンドの補完も実は既に LaTeX Workshop
にあるんですが、これは余り拡張しやすい感じにはなっていません。
また、個人的に YaTeX
のキラー機能だと思っているイメージ補完やセクション補完機能もありません。
CaTeX は、この<strong>YaTeX と LaTeX Workshop
のギャップを埋める</strong>というのが大きな動機の一つになっています。
ですので、上に挙げたような、LaTeX Workshop
で既に実現されている機能については、当面のところ CaTeX
で敢えてサポートする予定はありません。 LaTeX Workshop には YaTeX の
<kbd>C-c C-k</kbd> （Smart Kill）や <kbd>C-c C-c</kbd>
に相当するそのものズバリの機能はありませんが、LaTeX Workshop の “<em>Add
a multicursor to the current environment name</em>” や “<em>Navigate to
matching begin/end</em>” あるいは “<em>Select current environment
name</em>” あたりを使えばなんとかなるので、まだ手を着けてません。</p>
<p>また、YaTeX は Emacs が前提となる UI
の設計をしていますが、郷に入りては郷に、ローマにてはローマに、VSCode
では Microsoft に従え、ということで、<strong>YaTeX の機能をより VSCode
らしい方法で実現</strong>することを念頭に置いています。
なので、補完機能に関しても、VSCode の <strong>InteliSence
やコードスニペットの機能</strong>を使って実装して、他の機能拡張とシームレスに連携出来ような物を心掛けています。</p>
<p>では、以下各機能を順に見ていきましょう。</p>
<section id="ギリシア文字補完イメージ補完フォント補完" class="level3">
<h4>ギリシア文字補完、イメージ補完、フォント補完</h4>
<p>最初に書いておくと、実はまだ、VSCode
では他の機能拡張で提供されている構文定義から、構文上のスコープを得る方法が提供されていません。
これはつまり、手軽に「今カーソルのある場所が数式の内部なのか手軽に判定できない」という意味です。
という訳で、下記のギリシア<strong>文字補完、イメージ補完等は数式環境外でも呼び出せてしまう</strong>状態です。
まあ、TikZ 環境の中で <code class="sourceCode latex"><span class="fu">\matrix</span>[math nodes] { ... }</code>
と書かれててもイメージ補完が使えなかったりすることはよくあり、そういう点では望ましいかもしれませんが、普通の本文中（テキストモード）でも
<code>;</code> や <code>:</code>
を入力しようとしたら補完を解除しないといけないのは、ちょっと不便かもしれません。
その内なんとかなる、といいな……。</p>
<p>デモは以下の通り。 まず、<kbd>;</kbd> で数式補完が、<kbd>:</kbd>
でギリシア文字補完が走ります。</p>
<figure>
<img src="https://github.com/konn/catex/raw/master/images/image-and-greek.gif" alt="イメージとギリシア文字補完"></img>
<figcaption aria-hidden="true">イメージとギリシア文字補完</figcaption>
</figure>
<p>補完ではなく単に <code>:</code> や <code>;</code>
などのトリガー自身を入力したい時は、<kbd>Esc</kbd>キーでも押して補完をキャンセルすれば大丈夫です。
本家に合わせて二回押しとかにしても良いかもしれないですが、取り敢えず現状はこうなってます。</p>
<p>あと本家 YaTeX
にはデフォルトでは付いていませんが、<kbd>@</kbd>キーで数式フォント補完が走ります。
ただ、<kbd>@</kbd> は LaTeX Workshop
が提供している補完のプレフィックスと被っていて、使いづらいです。</p>
<p>また、キーボードだけではなくて、直接コマンドを呼び出すことでも補完を実行出来ます：</p>
<figure>
<img src="https://github.com/konn/catex/raw/master/images/image-invoked.gif" alt="イメージ、直接呼出"></img>
<figcaption aria-hidden="true">イメージ、直接呼出</figcaption>
</figure>
<p>補完のトリガーキーや辞書は <code>catex.image-completion</code>
を編集することでカスタマイズ出来ます。
例えば、デフォルトでは以下のような設定になっています：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;CaTeX Image Completion&quot;</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;languages&quot;</span><span class="op">:</span> [</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;latex&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  ]<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;triggers&quot;</span><span class="op">:</span> [</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;;&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  ]<span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;dictionary&quot;</span><span class="op">:</span> <span class="st">&quot;defaults/images.json&quot;</span><span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;renderMode&quot;</span><span class="op">:</span> <span class="st">&quot;latex&quot;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><code>renderMode</code> の部分は必須で、<code>triggers</code>
を空配列にすればホットキーは無効になり、直接呼出以外は出来なくなります。
<code>languages</code> の欄については、なんか生 TeX とか expl3
とかでも使いたくなったら入れてください。 <code>dictionary</code>
の部分がファイルになっていますが、これは <strong>CaTeX
に標準で同梱されているデフォルトの辞書</strong>
への参照になっていて、例えば、以下のように書き換えることができます：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>{ <span class="op">...</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;dictionary&quot;</span><span class="op">:</span> [</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;defaults/images.json&quot;</span><span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="co">// デフォルトでは \int のような \maketitle 型の補完になる。</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      { <span class="st">&quot;label&quot;</span><span class="op">:</span> <span class="st">&quot;{/&quot;</span><span class="op">,</span> <span class="st">&quot;body&quot;</span><span class="op">:</span> <span class="st">&quot;</span><span class="sc">\\</span><span class="st">notin&quot;</span><span class="op">,</span> <span class="st">&quot;description&quot;</span><span class="op">:</span> <span class="st">&quot;∉&quot;</span> }<span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>      {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;label&quot;</span><span class="op">:</span> <span class="st">&quot;wcheck&quot;</span><span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;body&quot;</span><span class="op">:</span> <span class="st">&quot;widecheck&quot;</span><span class="op">,</span> <span class="st">&quot;description&quot;</span><span class="op">:</span> <span class="st">&quot;✓ (wide accent)&quot;</span><span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;type&quot;</span><span class="op">:</span> <span class="st">&quot;section&quot;</span> <span class="co">// &quot;environment&quot; などもある</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>この補完機能は拙作の[Generic Input
Method]機能拡張を使って実現されています。
なので、他の補完機能を作りたくなったら、同じ要領で Input Method
の定義を書いて、<code>generic-input-methods.input-methods</code>
にでも追加しておけば大丈夫な筈です。</p>
</section>
<section id="セクション環境maketitle-そして-large-補完" class="level3">
<h4>セクション、環境、<code>\maketitle</code> そして
<code>{\Large }</code> 補完</h4>
<p>詳しくは<a href="https://marketplace.visualstudio.com/items?itemName=mr-konn.catex">Marketplace</a>や<a href="https://github.com/konn/catex">GitHub</a>に上がっているGIFを見て欲しいんですが、<kbd>C-c
*</kbd> 系の補完も用意してあります。
特に分ける意味もないので、例えばセクション補完では <kbd>C-c s</kbd>
を押すと、選択範囲があれば囲む形で、そうでなければ新しくスニペットを挿入する形になっています：</p>
<figure>
<img src="https://github.com/konn/catex/raw/master/images/section-1.gif" alt="Section Completion"></img>
<figcaption aria-hidden="true">Section Completion</figcaption>
</figure>
<p>また、YaTeXの補完機能 （や全く関係ないけど
AquaSKK）を偉大たらしめている<strong>その場での辞書登録機能</strong>も
CaTeX は提供しています。</p>
<figure>
<img src="https://github.com/konn/catex/raw/master/images/section-2.gif" alt="Section Completion in-place registration"></img>
<figcaption aria-hidden="true">Section Completion in-place
registration</figcaption>
</figure>
<p>折角 VSCode
のスニペット機能を使っているので、<strong>引数の仕様まで含めて登録</strong>することが出来るようにしました。
例えば二番目に <code>[]{}[]</code>
とか入力すると、オプション引数、固定引数、オプション引数の順だという定義になります。
オプション引数はまず括弧全体が選択されるので、不要なら削除することができます。
上図の通り、デフォルトのプレースホルダ文字列も指定出来て、<code>{foo}{}[bar]</code>とかすると、<code>\mycmd{foo}{}[bar]</code>という形で挿入されるので、デフォルトの内容が決まってる時や、引数の説明などを入れると良いでしょう。</p>
<p>選択範囲を囲む機能については、<code>\begin/\end</code>-補完では選択範囲を環境の本体として扱いますが、それ以外の補完については、</p>
<ol type="1">
<li>プレースホルダが <code>!</code> で始まっていればそこに挿入</li>
<li>そうでなければ一番最初の固定引数の所に挿入</li>
</ol>
<p>という仕様です。上のデモで <code>!here</code>
と書かれている場所がそうです。 上記 1
の場合の引数については、選択範囲が空の場合はそのまま <code>here</code>
部分がプレースホルダとして使用され、タブで往き来出来るようになります。
選択範囲が空でない場合は引数の内容として用いられ、その部分はスニペット展開では地の文として扱われタブでは無視されます。</p>
<p>以上のような機能は、<code>\begin{}...\end{}</code>-補完、<code>{\Large }</code>-補完、<code>\maketitle</code>-補完でも使うことが出来ます。
ただ、VSCode
は2ストロークまでしかショートカットを許可していないので、YaTeX でいう
<kbd>C-c b a</kbd>で <code>align</code> 環境を補完したり、<kbd>C-c b
[SPACE]</kbd>で環境名一覧を出したり、といった機能は実装できていません。
まあとはいえ、曖昧検索をしてくれるので、今のところそんなに不便を感じていません。</p>
<p>自動登録をしてもいいですが、辞書を手で編集することも出来ます。
例えば以下のような感じ：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;catex.environment.dictionary&quot;</span><span class="op">:</span> [</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;include&quot;</span><span class="op">:</span> <span class="st">&quot;defaults/environments.json&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;fact&quot;</span><span class="op">,</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;args&quot;</span><span class="op">:</span> [</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;kind&quot;</span><span class="op">:</span> <span class="st">&quot;optional&quot;</span><span class="op">,</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;placeholder&quot;</span><span class="op">:</span> <span class="st">&quot;title&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;remark&quot;</span><span class="op">,</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;args&quot;</span><span class="op">:</span> [</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;kind&quot;</span><span class="op">:</span> <span class="st">&quot;optional&quot;</span><span class="op">,</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;placeholder&quot;</span><span class="op">:</span> <span class="st">&quot;title&quot;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  ]<span class="op">,</span></span></code></pre></div>
<p>まあこれも、<a href="https://github.com/konn/catex/tree/master/defaults">GitHubで
<code>defaults/*.json</code></a>を見ればだいたい書き方がわかると思います。</p>
</section>
</section>
<section id="既知の問題" class="level2">
<h3>既知の問題</h3>
<section id="vscode-における日本語入力" class="level3">
<h4>VSCode における日本語入力</h4>
<p>これは CaTeX に限らない既知の問題ですが、VSCode
では日本語入力が乱れる、特に AquaSKK
との食い合わせが悪い、という事が知られています。
完全に解決は出来ませんが、余分な拡張をオフにすると若干改善します。特に、私の環境では単語ベースの
InteliSense 補完と Spell Right
機能拡張（自動スペルチェッカ）をオフにした所、完全にではないものの、許容出来る範囲まで文字列の乱れを軽減出来ました。</p>
<p>また、Emacs の要領で <kbd>C-g</kbd>
を連発していたりすると制御文字が溜まるので、<a href="https://marketplace.visualstudio.com/items?itemName=satokaz.vscode-bs-ctrlchar-remover">Remove
backpace control character</a>機能拡張を使うと良いでしょう。
とはいえ、たぶんこれエディタのテキストを <code>EditorTextEdit</code>
ではなく <code>text</code>
を置き換える形でやっていてあまり行儀がよくないのがちょっと不満です。</p>
</section>
</section>
</section>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr></hr>
<ol>
<li id="fn1" role="doc-endnote"><p>正直な話、Visual Studio Code のCLIが
<code>code</code>
って名前なのはどうなのよと思わなくはないんですが、そこはそれ。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
    </entry>
    <entry>
      <title>VSCode で YaTeX のイメージ補完やユニコード数式記号を入力する為の拡張をつくった</title>
      <link href="https://konn-san.com/prog/generic-input-method-and-latex-in-vscode.html" />
      <id>https://konn-san.com/prog/generic-input-method-and-latex-in-vscode.html</id>
      <published>2018-11-17T03:54:00+09:00</published>
      <updated>2018-11-17T03:54:00+09:00</updated>
      <summary type="html"><![CDATA[<p><strong><span style="color: red;">LaTeX機能は独立させて<a href="https://marketplace.visualstudio.com/items?itemname=mr-konn.catex">CaTeX</a>
として新たにリリースしました。Generic Input Method
を入れてもイメージ補完等は使えなくなったので、CaTeX
の方を入れてください。<a href="../articles/2018-11-26-happy-latex-with-catex.html">詳細なアナウンス</a>。</span></strong></p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<section id="はじめに" class="level1">
<h2>はじめに</h2>
<p><a href="./migrating-emacs-to-vscode.html">以前の記事</a>にも書いたように、最近は作業環境を
Emacs から VSCode に移行しています。</p>
<p>一方、どう考えても、Emacs
の方が機能拡張（パッケージ）は沢山あって、どうしても VSCode
には足りない部分も多くあります。 まあ Emacs
はその沢山あるパッケージを管理するシステムが壊滅に腐っていたから地獄だったわけで、それにくらべれば、VSCode
はしっかり考えて設計されており、今のところ大変快適です。</p>
<p>という訳で、仕方がないので LaTeX
向けの入力支援システムを作ってみました。 これがその
<code>generic-input-method</code> です：</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

<p>名前に LaTeX って入っていないのは、概要に書いたように LaTeX
の入力支援だけではなく、ユニコード文字を多用する定理証明系の入力支援にも使えるからです。</p>
<section id="demo" class="level2">
<h3>DEMO</h3>
<p>こんな感じで、YaTeX
のイメージ補完とギリシア文字補完っぽいのができます：</p>
<figure>
<img src="https://github.com/konn/vscode-generic-input-method/raw/master/images/image-and-greek.gif" alt="Greek and Image"></img>
<figcaption aria-hidden="true">Greek and Image</figcaption>
</figure>
<p>選択範囲を置き換えたり、包んだりするのに、別途コマンドパレットで呼び出すこともできます：</p>
<figure>
<img src="https://github.com/konn/vscode-generic-input-method/raw/master/images/image-invoked.gif" alt="Invoking"></img>
<figcaption aria-hidden="true">Invoking</figcaption>
</figure>
<p>ユニコード文字の入力はこんな感じ：</p>
<figure>
<img src="https://github.com/konn/vscode-generic-input-method/raw/master/images/unicode-input.gif" alt="Invoking"></img>
<figcaption aria-hidden="true">Invoking</figcaption>
</figure>
<p>詳しくは README
とか設定ファイルを読んでほしいですが、自分で新しい変換辞書を定義したり、新しい記号を足したり、ということもできます。</p>
<p>また、API
を露出してあるので、他の機能拡張から呼び出して使うこともできます。
一例として、この仕組みを使って実装した、定理証明系 <a href="https://github.com/RedPRL/redtt">redtt</a>
の入力支援パッケージが以下です：</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      


    </div>

</section>
<section id="latex-環境の設定" class="level2">
<h3>LaTeX 環境の設定</h3>
<p>オマケ的に VSCode 上での LaTeX
環境の整備について言うと、私のこれと、</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop">LaTeX
Workshop</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ajshort.latex-preview">LaTeX
Preview</a></li>
</ul>
<p>あたりがあれば大変快適に TeX 打ちが出来るようになった。
というか、書いている途中で気付いたんだけど、LaTeX Workshop
も、イメージ補完とギリシア文字補が合体したような機能があって、<kbd>@</kbd>を押すと有効化されるようだ。
とはいえ、この補完アイテムを自分で後から追加設定したりすることは出来ないようだし、多言語から呼ぶことも出来なさそうなので、こうして新しく作った甲斐はあったと思う。</p>
<p>他に似た用途の機能拡張だと、<a href="https://marketplace.visualstudio.com/items?itemName=yellpika.latex-input">latex-input</a>や<a href="https://marketplace.visualstudio.com/items?itemName=oijaz.unicode-latex">Unicode
LaTeX</a>というのがあるようだけど、辞書が一つしか持てなかったり、そもそも辞書をカスタマイズ出来るようになっていなかったり、API
を露出していなかったりする。</p>
<p>あと、多分変換を確定させる方法は <kbd>Enter</kbd>
しかどれも提供していないが、こちらでは「補完シーケンス中に出て来ない任意の文字」で確定するようにしてある。
とはいえ、つかってみてちょっと不便な場合もあるので、今後この辺りももっと柔軟に設定出来るようにする予定。
乞うご期待。</p>
</section>
</section>]]></summary>
    </entry>
</feed>
