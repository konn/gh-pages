<!DOCTYPE html><!--[if lt IE 7]>      <html lang="ja" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if IE 7]>         <html lang="ja" class="no-js lt-ie9 lt-ie8"> <![endif]--><!--[if IE 8]>         <html lang="ja" class="no-js lt-ie9"> <![endif]--><!--[if gt IE 8]><!--><html lang="ja" class="no-js"><!--<![endif]--><!--[if !IE]><html lang="ja"><![endif]--><head>
  <meta charset="utf-8">
  <title>Haskellerの私的Rustチートシート - konn-san.com</title>
  <meta name="author" content="Hiromi ISHII">
  <meta name="Keywords" content="Rust,Haskell,Programming,Tech,Programming Language"><meta name="description" content="Rustに入門したので、適宜HaskellのこれはRustのこれ、ということをここに蓄積していって、個人的なチートシートにする。
">
  <link href="/katex/katex.min.css" type="text/css" rel="stylesheet">
  <meta name="viewport" content="width=device-width">
  <link rel="canonical" href="https://konn-san.com/prog/rust-memo.html">
  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Atom Feed">
  <link href="/css/bootstrap.min.css" rel="stylesheet" media="screen">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="/css/syntax.css" rel="stylesheet" media="screen">
  <link href="/css/style.css" rel="stylesheet" media="screen">
  


  <script src="//b.st-hatena.com/js/bookmark_button_wo_al.js" async="async">
  </script>
  <script src="/js/vendor/modernizr-2.6.2.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML" async="async"></script>
  <script src="//s.hatena.ne.jp/js/HatenaStar.js"></script>
  <script>
  Hatena.Star.Token = '7bf3845df18764ea7bfa120294f8c5ed1cd371e9';
  Hatena.Star.SiteConfig = {
    entryNodes: {
      'div.container': {
        uri: 'window.location',
        title: 'document.title',
        container: 'ul#socials li#hatena-star'
      }
    }
  };
  </script>
  <!-- Twitter Card -->
  <meta property="twitter:card" content="summary">
  <meta property="twitter:site" content="@mr_konn">
  <meta property="og:url" content="https://konn-san.com/prog/rust-memo.html">
  <meta property="og:title" content="Haskellerの私的Rustチートシート">
  <meta property="og:description" content="Rustに入門したので、適宜HaskellのこれはRustのこれ、ということをここに蓄積していって、個人的なチートシートにする。 ">
  <meta property="og:image" content="https://konn-san.com/img/myface_mosaic.jpg">
  <!-- /Twitter Card -->
</head>
<body>
  <!--[if lt IE 7]>
    <p class="chromeframe">Sorry, this site doesn't support IE version &lt;7. <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
  <![endif]-->
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
  <a class="navbar-brand" href="/">konn-san.com</a>
  <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#Navbar" aria-controls="Navbar" aria-expanded="false" aria-label="toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="Navbar">
    <ul class="navbar-nav mr-auto">
     <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
     <li class="nav-item"><a class="nav-link" href="/profile.html">Profile</a></li>
     <li class="nav-item"><a class="nav-link" href="/math">Math</a></li>
     <li class="nav-item active"><a class="nav-link" href="/prog">Tech</a></li>
     <li class="nav-item"><a class="nav-link" href="/writing">Writings</a></li>
     <li class="nav-item"><a class="nav-link" href="/articles">Articles</a></li>
     <li class="nav-item"><a class="nav-link" href="/logs">Logs</a></li>
     <li class="nav-item"><a class="nav-link" href="/archive.html">Archive</a></li>
    </ul>
    <form class="form-inline my-2 my-lg-0" action="https://cse.google.com/" target="_blank">
      <input type="hidden" name="cx" value="008926939897329001532:wsmollxek8o">
      <input class="form-control mr-sm-2" type="text" name="q" placeholder="Search" aria-label="Search" required>
      <button class="btn btn-outline-secondary my-2 my-sm-0" type="submit">
        <i class="fa fa-search"></i>
      </button>
    </form>
  </div>
</nav>

  <div class="container">
   <ol class="breadcrumb">
    <li class="breadcrumb-item"><a href="/">konn-san.com 建設予定地</a></li>
    <li class="breadcrumb-item"><a href="/prog/">プログラミング関連</a></li>
  <li class="li breadcrumb-item active">Haskellerの私的Rustチートシート</li>
</ol>

    <div class="page-header">
    <h1>Haskellerの私的Rustチートシート <small>konn-san.com</small></h1>
    <div id="social">
      <i class="fa fa-bookmark" aria-hidden="true"></i>
      <ul id="socials">
      <li id="facebook">
      <div class="fb-like" data-href="https://konn-san.com/prog/rust-memo.html" data-send="false" data-layout="button_count" data-width="450" data-show-faces="true"></div>
      </li><li id="hatena-bookmarks">
        <a href="//b.hatena.ne.jp/entry/https://konn-san.com/prog/rust-memo.html" class="hatena-bookmark-button" data-hatena-bookmark-title="Haskellerの私的Rustチートシート - konn-san.com" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="//b.st-hatena.com/images/entry-button/button-only.gif" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;"></a><script src="//b.st-hatena.com/js/bookmark_button.js" async="async"></script>
      </li><li>
      <script src="//apis.google.com/js/plusone.js"></script>
      <div class="g-plusone" data-size="standard" data-count="true"></div>
      </li><li>
      <a href="//twitter.com/share" class="twitter-share-button" data-via="mr_konn" data-lang="ja">ツイート</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
      </li><li id="hatena-star">
      </li></ul>
    </div>
    <div><i class="fa fa-calendar" aria-hidden="true"></i> posted on 2018/08/29 18:47:20 JST</div>
    </div>
    <hr>
        <div id="page-main" data-offset="0" class="page-content text-justify" data-spy="scroll" data-target="#side-toc">
          <p>Rustに入門したので、適宜HaskellのこれはRustのこれ、ということをここに蓄積していって、個人的なチートシートにする。</p>
<section id="borrow-と-ownership" class="level1">
<h2>Borrow と Ownership</h2>
<ul>
<li>基本的に Region Monad
と線型型（呼ばなくても良いので正確にはアファイン型）が組込みだと思えばよい。
<ul>
<li><code>{</code> から <code>}</code>
までの間でスコープが区切られ、スコープごとに <code>Drop</code>
（＝<code>free</code>）がされる。</li>
</ul></li>
</ul>
</section>
<section id="プロジェクト管理" class="level1">
<h2>プロジェクト管理</h2>
<ul>
<li>Stack に当たるのが cargo</li>
<li><code>stack.yaml</code> は <code>Cargo.toml</code></li>
<li>コードは <code>src</code> 直下固定。<code>src/main.rs</code> が
<code>Main.hs</code> 相当で、<code>src/lib.rs</code>
がライブラリのルートに当る。</li>
</ul>
</section>
<section id="モジュールシステム" class="level1">
<h2>モジュールシステム</h2>
<ul>
<li>一つの <code>.rs</code>
ファイル内で複数のモジュールを、ネストして定義出来る。</li>
<li><code>mod a;</code>
のように定義を省略した場合、<code>a.rs</code>の内容がモジュール
<code>a</code> の定義として扱われる。</li>
<li><code class="sourceCode rust"><span class="pp">foo::bar::</span>buz</code>
に当るファイルは <code>src/foo/bar/buz.rs</code>。
<ul>
<li>このファイルの存在下では、<code>foo::bar</code> に当るのは
<code>src/foo/bar/mod.rs</code>。</li>
</ul></li>
<li>Haskellの <code class="sourceCode haskell"><span class="kw">import</span></code>
に近いのは <code class="sourceCode rust"><span class="kw">use</span></code>。
<ul>
<li><code class="sourceCode rust"><span class="kw">use</span> <span class="pp">a::b::</span>c</code>
と宣言しておくと、以後モジュール <code>a::b</code> 以下の定義は <code class="sourceCode rust"><span class="pp">b::</span>fun</code>
などと呼び出せるようになる。</li>
</ul></li>
</ul>
</section>
<section id="字句構造" class="level1">
<h2>字句構造</h2>
<ul>
<li>基本的に全て式だが、<code>()</code> 返すのが文。</li>
<li>関数の最後で値を返す際には <code class="sourceCode rust"><span class="cf">return</span></code>
は不要。</li>
<li>ただし式の最後に <code>;</code>
を付けると文になってしまうので、生の式で値を返す場合は <code>;</code>
を付けないように。</li>
<li>Haskell と違い、変数はバシバシ shadowing していく文化。
<ul>
<li><strong>注意</strong>：Shadowing
された変数にアクセスする方法はないが、shadowing
されてもスコープが区切られなければ Drop はされない。</li>
</ul></li>
<li>コメントは一行コメントのみ：<code class="sourceCode rust"><span class="co">// これはコメントです</span></code></li>
<li>ここに入れていいのかわからないが、インデントは4スペース。</li>
</ul>
</section>
<section id="変数束縛" class="level1">
<h2>変数束縛</h2>
<ul>
<li><code class="sourceCode rust"><span class="kw">let</span> a<span class="op">:</span> T <span class="op">=</span> b</code>
は不変変数宣言。</li>
<li><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> a<span class="op">:</span> T <span class="op">=</span> b</code>
は可変変数。</li>
<li><code class="sourceCode rust"><span class="kw">static</span> A<span class="op">:</span> T <span class="op">=</span> b</code>
は定数宣言。</li>
<li><code class="sourceCode rust"><span class="kw">static</span></code>
以外は型註釈はある程度省略出来る。</li>
<li>あとは <code class="sourceCode rust"><span class="op">&amp;</span></code> とか <code class="sourceCode rust"><span class="kw">ref</span></code>
とかの修飾子が適宜つく。</li>
</ul>
</section>
<section id="制御構造" class="level1">
<h2>制御構造</h2>
<ul>
<li><code class="sourceCode haskell"><span class="kw">if</span></code>
に相当するのは <code>if (...) { } else { .. }</code>
<ul>
<li><code>else</code> 節は省略可。複数の <code>else if</code>
を連ねることもできる。</li>
</ul></li>
<li><code class="sourceCode haskell"><span class="kw">case</span></code>
に相当するのは <code class="sourceCode rust"><span class="cf">match</span> expr <span class="op">{</span> case <span class="op">=&gt;</span> alt<span class="op">,</span> <span class="op">...}</span></code>
<strong>および</strong> <code class="sourceCode rust"><span class="cf">if</span> <span class="kw">let</span> case <span class="op">=</span> expr <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></code>。
<ul>
<li><p><code class="sourceCode rust"><span class="cf">match</span></code> 式は
Haskell の <code>case</code> 相当だが、<strong>exhaustive
（全場合列挙）でないとエラー</strong>になる。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">match</span> a <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  A(x) <span class="cf">if</span> x <span class="op">==</span> <span class="dv">0</span>  <span class="op">=&gt;</span>  <span class="st">&quot;zero of A&quot;</span><span class="op">,</span>       <span class="co">// ガードみたいなのも出来る</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  A(x<span class="op">@</span><span class="dv">10</span> <span class="op">...</span> <span class="dv">13</span>)  <span class="op">=&gt;</span> <span class="st">&quot;10...13&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// アズパターンみたいのがあるが、所有権の関係で「別名」付けるのは無理そう</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  A(x)            <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Non zero A({}) found&quot;</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;boo&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">},</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  B(x) <span class="op">|</span> C(x) <span class="op">=&gt;</span> <span class="st">&quot;Or!&quot;</span> <span class="co">// オアパターンが出来る</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  B(x) <span class="op">|</span> C(x) <span class="cf">if</span> x <span class="op">==</span> <span class="dv">0</span> <span class="op">=&gt;</span> <span class="st">&quot;Or!&quot;</span> <span class="co">// if はオアより結合が弱い。</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  _ <span class="op">=&gt;</span> <span class="st">&quot;baz&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><code class="sourceCode rust"><span class="cf">if</span> <span class="kw">let</span></code>
はHaskellでの<strong>partialな<code class="sourceCode haskell"><span class="kw">case</span></code></strong>に当る。</p>
<ul>
<li><code class="sourceCode rust"><span class="cf">else</span> <span class="cf">if</span> <span class="kw">let</span> p <span class="op">=</span> e <span class="op">{</span> <span class="op">...</span> <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></code>
のように連ねたりfallback で else が使える。</li>
</ul></li>
</ul></li>
<li>ループ：<code class="sourceCode rust"><span class="cf">while</span> p <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></code>
および <code class="sourceCode rust"><span class="cf">loop</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></code>
<ul>
<li>スコープとlifetimeの関係で、条件判定やパタンマッチを <code class="sourceCode rust"><span class="cf">while</span></code>
の条件部ではなく <code class="sourceCode rust"><span class="cf">loop</span><span class="op">{</span> <span class="op">...</span> <span class="op">}</span></code>
内部でやった方が適切な場合あり。</li>
</ul></li>
<li><code class="sourceCode haskell"><span class="dt">TypeApplications</span></code>:
GHCの<code class="sourceCode haskell"><span class="dt">TypeApplications</span></code>
での <code class="sourceCode haskell">f <span class="op">@</span><span class="dt">T</span> xs</code>
に当るのは <code class="sourceCode rust"><span class="pp">f::</span><span class="op">&lt;</span>T<span class="op">&gt;</span>(xs)</code>。ワイルドカードも使える：<code>f::&lt;Vec&lt;_&gt;&gt;(xs)</code>。</li>
</ul>
</section>
<section id="データ型" class="level1">
<h2>データ型</h2>
<ul>
<li><p><code class="sourceCode rust">Int16<span class="op">,</span> Int32<span class="op">,</span> Int64<span class="op">,</span> Word16<span class="op">,</span> Word32<span class="op">,</span> Word64</code>
に当るのが <code class="sourceCode rust"><span class="dt">i16</span><span class="op">,</span> <span class="dt">i32</span><span class="op">,</span> <span class="dt">i64</span><span class="op">,</span> <span class="dt">u16</span><span class="op">,</span> <span class="dt">u32</span><span class="op">,</span> <span class="dt">u64</span></code>。
ポインタアドレス等、アーキテクチャ依存の整数型（<code class="sourceCode haskell"><span class="dt">Int</span></code> や <code class="sourceCode haskell"><span class="dt">Word</span></code>）は <code class="sourceCode rust"><span class="dt">isize</span></code> (符号付) や
<code class="sourceCode rust"><span class="dt">usize</span></code>
(符号無)。</p></li>
<li><p><code class="sourceCode rust"><span class="kw">struct</span></code> や <code class="sourceCode rust"><span class="kw">enum</span></code> が Haskell
の <code class="sourceCode haskell"><span class="kw">data</span></code>
や <code class="sourceCode haskell"><span class="kw">newtype</span></code>
に当る。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Struct <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  fld<span class="op">:</span> <span class="dt">i64</span><span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Enum <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  A(<span class="dt">i64</span>)<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  B <span class="op">{</span> val<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> dull<span class="op">:</span> <span class="dt">i16</span><span class="op">,</span> <span class="op">},</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><code class="sourceCode rust"><span class="kw">struct</span></code>
は直積型、<code class="sourceCode rust"><span class="kw">enum</span></code>
は直和型。</p>
<ul>
<li><code class="sourceCode rust"><span class="kw">enum</span></code>の各コンストラクタを<strong>variant</strong>と言う。</li>
<li>フィールドラベルのついた <code class="sourceCode rust"><span class="kw">struct</span> F <span class="op">{</span> a<span class="op">:</span> <span class="dt">i64</span> <span class="op">}</span></code>
と、ついていないタプル構造型 <code class="sourceCode rust"><span class="kw">struct</span> F(<span class="dt">i64</span>)</code>
は全く違うもの。</li>
</ul></li>
<li><p>再帰型は <code class="sourceCode rust"><span class="dt">Box</span><span class="op">&lt;</span>a<span class="op">&gt;</span></code>
などに包んで間接的に参照の形で持つ。</p>
<ul>
<li>フィールドの値や関数の引数は、<strong>メモリ上でのサイズが確定</strong>していないといけないので。</li>
</ul></li>
<li><p>コンストラクタは <code class="sourceCode rust"><span class="pp">Enum::</span>A</code>
のように呼ぶ。</p>
<ul>
<li>ここでも <code class="sourceCode rust"><span class="kw">use</span></code> が使え、<code class="sourceCode rust"><span class="kw">use</span> <span class="pp">Struct::</span><span class="op">*</span></code>
や <code class="sourceCode rust"><span class="kw">use</span> <span class="pp">Enum::</span><span class="op">*</span></code>
のようにすると、単に<code class="sourceCode rust">A(<span class="dv">12</span>)</code>や<code class="sourceCode rust">B <span class="op">{</span> val<span class="op">:</span> <span class="dv">12</span><span class="op">,</span> dull<span class="op">:</span> <span class="dv">54</span> <span class="op">}</span></code>
のように呼べる。</li>
</ul></li>
<li><p><code class="sourceCode haskell"><span class="dt">NamedFieldPuns</span></code>
拡張のようなことが出来、<code class="sourceCode rust">Foo <span class="op">{</span> bar <span class="op">}</span></code>
とやるとスコープにある <code>bar</code> の値が
<code>bar</code>フィールド<code>bar</code> の値になる。</p>
<ul>
<li>逆にパターンの来る文脈で <code class="sourceCode rust"><span class="kw">let</span> P <span class="op">{</span>x <span class="op">,</span> y<span class="op">}</span> <span class="op">=</span> p</code>
とすればフィールド <code>x</code>, <code>y</code> の値が変数
<code>x</code>, <code>y</code> にバインドされる。</li>
</ul></li>
<li><p>レコードの更新：<code class="sourceCode rust">d <span class="op">=</span> D <span class="op">{</span> field<span class="op">:</span> a<span class="op">,</span> gield<span class="op">:</span> b <span class="op">}</span></code>
のとき、 Haskellでいう <code class="sourceCode haskell">d { field <span class="ot">=</span> val }</code>
は Rust だと <code class="sourceCode rust">D <span class="op">{</span> field<span class="op">:</span> val<span class="op">,</span> <span class="op">..</span> d <span class="op">}</span></code>
となる。</p></li>
<li><p>ベクトル：<code>Vec&lt;T&gt;</code>。リストリテラルのように作るのは
<code class="sourceCode rust"><span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]</code>。</p>
<ul>
<li>固定長ベクトルは <code class="sourceCode rust">[T<span class="op">;</span> <span class="dv">3</span>]</code>
のよう。</li>
</ul></li>
</ul>
</section>
<section id="モナドと例外失敗処理" class="level1">
<h2>モナドと例外・失敗処理</h2>
<ul>
<li>モナドはない。
<ul>
<li>でも将来に向けて <code class="sourceCode rust"><span class="kw">do</span></code>
は予約語になっているようだ。</li>
</ul></li>
<li>例外機構はなく、<code class="sourceCode rust">panic</code>を使って自殺するか、後述の <code class="sourceCode rust"><span class="dt">Result</span></code>
を使っていくのがよいとされているようだ。</li>
<li><code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>
に対応するのが <code class="sourceCode haskell"><span class="dt">Option</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span></code>。
<code class="sourceCode haskell"><span class="dt">Nothing</span></code>と<code>Just a</code>には{.hs}
には <code class="sourceCode rust"><span class="cn">Some</span>(a)</code> と <code class="sourceCode rust"><span class="cn">None</span></code>が対応。
<ul>
<li><code class="sourceCode rust"><span class="dt">Option</span></code>
を <code class="sourceCode rust">panic</code>に変換するには：
<ul>
<li><code class="sourceCode haskell">fromJust ma</code> <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">=</span></span></span></span></span></span> <code>ma.unwrap()</code></li>
<li><code class="sourceCode haskell">fromMaybe (<span class="fu">error</span> <span class="st">&quot;unko&quot;</span>) ma</code>
<span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">=</span></span></span></span></span></span> <code class="sourceCode rust">ma<span class="op">.</span>expect(<span class="st">&quot;unko&quot;</span>)</code></li>
</ul></li>
</ul></li>
<li><code class="sourceCode haskell"><span class="dt">Either</span> a b</code>
に対応するのが <code class="sourceCode rust"><span class="dt">Result</span><span class="op">&lt;</span>B<span class="op">,</span> A<span class="op">&gt;</span></code>
<ul>
<li><code class="sourceCode haskell"><span class="dt">Right</span> a</code> <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">=</span></span></span></span></span></span> <code class="sourceCode rust"><span class="cn">Ok</span>(a)</code>, <code class="sourceCode haskell"><span class="dt">Left</span> b</code> <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">=</span></span></span></span></span></span> <code class="sourceCode rust"><span class="cn">Err</span>(b)</code></li>
<li>ライブラリ毎に <code class="sourceCode rust"><span class="kw">type</span> MyResult<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> MyError<span class="op">&gt;</span></code>
のような別名を用意している。</li>
<li><strong>順番に注意</strong>！Haskell
の流儀では二番目の型引数が「成功」だが、Rustでは<strong>最初の型引数が成功値</strong>。</li>
<li><code>unwrap()</code> と <code class="sourceCode rust">expect(<span class="st">&quot;foo&quot;</span>)</code>は同様に使える。</li>
<li>モナドはないが、SwiftやCoffeeScriptの <code>?</code>
オペレータと同じようなものがある。
<code>rs     fn proc(opt_arg: Option&lt;i64&gt;) -&gt; Result&lt;i16,SomeError&gt;  {         let a = opt_arg?.some_method().still_perhaps_failling()?;         println!(&quot;Hahaha&quot;);         { some heavy proc ... }         Ok(42)     }</code>
とかあったら、<code>?</code>が付いてる値が <code class="sourceCode rust"><span class="cn">Err</span>(hoge)</code>
だった場合、なんかいいかんじの変換が成されて直ちに <code class="sourceCode rust"><span class="cn">Err</span></code>
が返るようになる（注：Haskellと違いRustにはearly returnがある）。
<ul>
<li><p>但し関数定義（<code class="sourceCode rust"><span class="cf">return</span></code>が呼べるところ）でしか使えない。</p></li>
<li><p>qnighy氏の記事によれば、nightly では <code class="sourceCode rust"><span class="kw">do</span> catch</code>
構文があるようだが、stableには入ってない模様。</p>
    <div class="embed w-100 my-4 justify-content-center row py-0">
      <iframe scrolling="no" frameborder="0" class="col-md-10 col-12 align-self-center embed-item" src="//hatenablog-parts.com/embed?url=https://qnighy.hatenablog.com/entry/2017/06/03/070000">
</iframe>

    </div>
</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="オーバーロード" class="level1">
<h2>オーバーロード</h2>
<ul>
<li><p>Haskell の型クラスに当るのがトレイト（<code class="sourceCode rust"><span class="kw">trait</span></code>）</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Trait<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">,</span> U<span class="op">&gt;:</span> <span class="pp">this::is::</span>SuperTrait <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> F  <span class="co">// 関連型（associated type）もある</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  fn foo<span class="op">&lt;</span>T<span class="op">&gt;</span>(args<span class="op">:</span> <span class="dt">i64</span><span class="op">,</span> <span class="op">...</span>)  <span class="op">-&gt;</span> result<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> Trait<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">,</span> T<span class="op">&gt;</span> <span class="cf">for</span> MyStruct <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> </span></code></pre></div></li>
<li><p>Rust
は「ゼロコスト抽象」を謳っており、使用したトレイトの実装は自動的に特殊化されコードが生成される。</p>
<ul>
<li>いわば、<code class="sourceCode haskell"><span class="dt">SPECIALISE</span></code>
プラグマが適宜有効化されたような状態になっている。</li>
</ul></li>
<li><p>デフォルトで <code class="sourceCode haskell"><span class="dt">OverlappingInstances</span></code>
状態。</p></li>
<li><p>存在型：トレイト制約付きの存在型（existential type）は<code class="sourceCode rust"><span class="kw">dyn</span></code>で作る。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Showable</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkShowable</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Showable</span></span></code></pre></div>
<p>に対応するのは、</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Showable(<span class="kw">dyn</span> <span class="bu">Display</span>)<span class="op">;</span></span></code></pre></div>
<ul>
<li><code class="sourceCode rust"><span class="kw">dyn</span></code>
は動的にディスパッチするので、ゼロコスト抽象は効かない。</li>
</ul></li>
</ul>
</section>
          <hr>
          <!-- DISQUS -->
          <section id="disqus_area" class="mx-1 mx-md-3 mx-lg-5">
            <h2>Comments</h2>
          <div id="disqus_thread"></div>
          <script>
          var disqus_config = function () {
          this.page.url = "https://konn-san.com/prog/rust-memo.html";
          this.page.identifier = "/prog/rust-memo.html";
          };
          (function() { // DON'T EDIT BELOW THIS LINE
          var d = document, s = d.createElement('script');
          s.src = 'https://konn-san.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
          })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          </section>
          <!-- /DISQUS -->
        </div>
      </div>
  <footer>
      <p>
        <a href="//validator.w3.org/check?uri=https%3A%2F%2Fkonn-san.com/prog/rust-memo.html">
          <img src="/img/HTML5_Logo_32.png" height="32" alt="HTML5">
	</a>
	<br>
	Powered by <a href="https://shakebuild.com">Shake</a>,
        <a href="https://github.com/konn/sake">Sake</a>,
	<a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>,
	<a href="https://khan.github.io/KaTeX/">KaTeX</a>,
	<a href="https://www.mathjax.org">MathJax</a>,
        and <a href="http://nginx.org/">Nginx</a>.
	<br>
	Copyright © Hiromi ISHII 2012-2018
      </p>
    </footer>
  <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script>
      var _gaq=[['_setAccount','UA-29894567-2'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>


</body></html>
